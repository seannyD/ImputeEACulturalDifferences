edge.length=edge.length,
Nnode=1)
class(tip)<-"phylo"
obj<-bind.tree(tree,tip,where=where)
return(obj)
}
setNodeToTip = function(nodeName,tree, edge.length=0.001){
bind.tip(tree,nodeName, edge.length,which(tree$node.label==nodeName)[1] + length(tree$tip.label))
}
downloadTree <- function(glottoid){
url = paste("http://glottolog.org/resource/languoid/id/",glottoid,'.newick.txt',sep='')
tx = readLines(url)
return(tx[1])
}
#' Download glottolog trees from the web and convert to phylo objects
#'
#' @param glottoid The glottoid of the family to get (will be downloaded from the web) or local filename.
#' @param nodeLabelsBy How should the node labels be returned?  Glottolog trees have nodes labelled with glottoids, language names and sometimes iso codes. Defaults to "glottoid" for returning glottoids.
#' @param langNodesToTips Some languages in glottolog are not tips on the tree, but nodes with children (e.g. for languages with dialects).  If langNodesToTips is TRUE, the returned tree has extra tips for all nodes with non-blank labels.
#' @return phylo tree
#' @keywords Glottolog
#' @export
#' @examples
#' phy <- getGlottologTree("atla1278","glottoid")
getGlottologTree <- function(glottoid, nodeLabelsBy="glottoid", langNodesToTips=F, dichotomosTree=F){
if(grepl("^[a-z][a-z][a-z][a-z][0-9][0-9][0-9][0-9]$",glottoid)){
tx = downloadTree(glottoid)
} else{
tx = readLines(glottoid)[1]
}
# Add ending semicolon so that read.newick works
if(substr(tx,nchar(tx),nchar(tx))!=";"){
tx = paste(tx,";",sep='')
}
phy<-phytools::read.newick(text=tx)
phy$tip.label = editGlottologTipLabels(phy$tip.label,nodeLabelsBy)
phy$node.label = editGlottologTipLabels(phy$node.label,nodeLabelsBy)
if(langNodesToTips){
for(nx in phy$node.label[phy$node.label!='']){
phy = setNodeToTip(nx,phy)
}
}
if(dichotomosTree){
phy = ape::multi2di(phy)
}
return(phy)
}
#
phy <- getGlottologTree("atla1278","glottoid")
phy
#' Convert golottolog tip labels
#'
#' @param X vector of labels.
#' @param nodeLabelsBy How should the node labels be returned?  Glottolog trees have nodes labelled with glottoids, language names and sometimes iso codes. Defaults to "glottoid" for returning glottoids.
#' @return vector of node labels
#' @keywords Glottolog
#' @examples
#' phy$tip.label = editGlottologTipLabels(phy$tip.label,"glottoid")
#'
editGlottologTipLabels = function(X, nodeLabelsBy="glottoid"){
item = 2 # glottoid by default
if(is.numeric(nodeLabelsBy)){
item = nodeLabelsBy
} else{
if(nodeLabelsBy=="name"){
item = 1
}
if(nodeLabelsBy=="iso"){
item = 3
}
}
X = gsub("\\]","[",X)
return(
sapply(strsplit(X,"\\["),function(z){
if(length(z)>=item){
return(z[item])
} else{
return("")
}
}))
}
bind.tip<-function(tree,tip.label,edge.length=NULL,where=NULL){
if(is.null(where)) where<-length(tree$tip)+1
tip<-list(edge=matrix(c(2,1),1,2),
tip.label=tip.label,
edge.length=edge.length,
Nnode=1)
class(tip)<-"phylo"
obj<-bind.tree(tree,tip,where=where)
return(obj)
}
setNodeToTip = function(nodeName,tree, edge.length=0.001){
bind.tip(tree,nodeName, edge.length,which(tree$node.label==nodeName)[1] + length(tree$tip.label))
}
nodesToTips = function(phy, nodesToFix = phy$node.label[phy$node.label!='']){
for(nx in nodesToFix){
phy = setNodeToTip(nx,phy)
}
return(phy)
}
downloadTree <- function(glottoid){
url = paste("http://glottolog.org/resource/languoid/id/",glottoid,'.newick.txt',sep='')
tx = readLines(url)
return(tx[1])
}
#' Download glottolog trees from the web and convert to phylo objects
#'
#' @param glottoid The glottoid of the family to get (will be downloaded from the web) or local filename.
#' @param nodeLabelsBy How should the node labels be returned?  Glottolog trees have nodes labelled with glottoids, language names and sometimes iso codes. Defaults to "glottoid" for returning glottoids.
#' @param langNodesToTips Some languages in glottolog are not tips on the tree, but nodes with children (e.g. for languages with dialects).  If langNodesToTips is TRUE, the returned tree has extra tips for all nodes with non-blank labels.
#' @return phylo tree
#' @keywords Glottolog
#' @export
#' @examples
#' phy <- getGlottologTree("atla1278","glottoid")
getGlottologTree <- function(glottoid, nodeLabelsBy="glottoid", langNodesToTips=F, dichotomosTree=F){
if(grepl("^[a-z][a-z][a-z][a-z][0-9][0-9][0-9][0-9]$",glottoid)){
tx = downloadTree(glottoid)
} else{
tx = readLines(glottoid)[1]
}
# Add ending semicolon so that read.newick works
if(substr(tx,nchar(tx),nchar(tx))!=";"){
tx = paste(tx,";",sep='')
}
phy<-phytools::read.newick(text=tx)
phy$tip.label = editGlottologTipLabels(phy$tip.label,nodeLabelsBy)
phy$node.label = editGlottologTipLabels(phy$node.label,nodeLabelsBy)
if(langNodesToTips){
phy = nodesToTips(phy)
}
if(dichotomosTree){
phy = ape::multi2di(phy)
}
return(phy)
}
#
phy <- getGlottologTree("atla1278","glottoid")
phy
?readLines
phy <- getGlottologTree("atla1278","glottoid", langNodesToTips = T)
phy
'gola1255' %in% phy$tip.labels
plot(phy)
d = read.csv("~/Downloads/midata8613.csv")
head(d)
d$X.Date
as.Date(d$X.Date)
as.Date(as.character(d$X.Date))
?as.Date(as.character(d$X.Date))
as.Date(as.character(d$X.Date),"%d/%m/%Y")
d$date = as.Date(as.character(d$X.Date),"%d/%m/%Y")
plot(d$Balance,d$date)
plot(d$Balance~d$date)
plot(d$date,d$Balance)
plot(d$date,d$Balance, type = 'line')
head(d)
head(d$Balance)
d$Balance = as.numeric(d$Balance)
d$Balance
d$date = as.Date(as.character(d$X.Date),"%d/%m/%Y")
d$date = as.Date(as.character(d$X.Date),"%d/%m/%Y")
as.numeric(as.character(substring(d$Balance,2))
head(d$Balance)
as.numeric(as.character(substring(d$Balance,2)))
d$date = as.Date(as.character(d$X.Date),"%d/%m/%Y")
head(d$Balance)
d = read.csv("~/Downloads/midata8613.csv")
d$date = as.Date(as.character(d$X.Date),"%d/%m/%Y")
head(d$Balance)
as.numeric(as.character(substring(d$Balance,2)))
substring(d$Balance,2)
?substring(d$Balance,2)
X = head(d$Balance)
X
d$Balance = as.character(d$Balance)
d$Balance
X = head(d$Balance)
substring(X,2)
substring(X,1)
substring(X,4)
substring(X,3)
as.numeric(as.character(substring(d$Balance,3)))
d = read.csv("~/Downloads/midata8613.csv")
d$date = as.Date(as.character(d$X.Date),"%d/%m/%Y")
d$Balance = as.character(d$Balance)
d$Balance = as.numeric(as.character(substring(d$Balance,3)))
plot(d$date,d$Balance, type = 'line')
abline(as.Date(2017-01-01))
abline(v=as.Date(2017-01-01))
abline(h=as.Date(2017-01-01))
as.Date(2017-01-01)
abline(h=as.Date("2017-01-01"))
abline(v=as.Date("2017-01-01"))
abline(v=as.Date("2017-02-01"))
abline(v=as.Date("2017-03-01"))
d
d[45:46,]
factor(10)
factorial(10)
factorial(20)
numberOfSamples = 137
numberOfSamples/2
68 + 68
d = read.csv("~/Documents/MPI/LuisM_K_Pronoun/data/Alldata_simple.csv", stringsAsFactors = F)
head(d)
names(d)
g = read.csv("~/Documents/MPI/Glottolog/glottolog-languoid.csv/languoid.csv",stringsAsFactors = F)
names(g)
g$family = g[match(g$family_pk,g$pk),]$name
head(g$id)
d$family = g[match(d$glotto,g$id),]$family
head(d$family)
table(d$family)
d2 = d[d$family=="Uto-Aztecan",]
table(d2$meaning.id)
table(d2$Language)
d = read.delim("~/Documents/MPI/LuisM_K_Pronoun/BEAST_analysis/models/2017/relaxedClock_excludeSmall/relaxedClock_resampled.log",sep="\t", skip = 790, nrows = 10)
head(d)
plot(d$posterior)
d = read.delim("~/Documents/MPI/LuisM_K_Pronoun/BEAST_analysis/models/2017/relaxedClock_excludeSmall/relaxedClock_resampled.log",sep="\t", skip = 790, nrows = 20000)
plot(d$posterior)
plot(log(d$posterior))
plot(log(absd$posterior))
plot(log(abs(d$posterior)))
plot((d$posterior))
plot((d$posterior[3:nrow(d)]))
library(RColorBrewer)
RColorBrewer::display.brewer.all()
?RColorBrewer::display.brewer.all()
?display.brewer.all()
RColorBrewer::display.brewer.all(colorblindFriendly=T)
?display.brewer.all(colorblindFriendly=T)
brewer.pal(4,'Dark2')
plot(1:4,col=brewer.pal(4,'Dark2'),pch=15, cex=4)
plot(1:4,col=brewer.pal(4,'Set2'),pch=15, cex=4)
plot(1:6,col=brewer.pal(6,'Set2'),pch=15, cex=4)
plot(1:6,col=brewer.pal(6,'Dark2'),pch=15, cex=4)
pi
pi*0.5
library(REEMtree)
n = 300
x = as.factor(sample(1:4,n,replace = T))
y = as.factor(sample(1:4,n,replace = T))
REEMtree(x~y)
r = as.factor(rep(1:2,n/2))
library(REEMtree)
n = 300
x = as.factor(sample(1:4,n,replace = T))
y = as.factor(sample(1:4,n,replace = T))
r = as.factor(rep(1:2,n/2))
data = data.frame(x=x,y=y,r=r)
REEMtree(x~y,data=data,random=r)
x
# USE the mice package to do multiple imputation.
# The method used is classification trees.
#  Language family is added as a variable with which the tree can make guesses about the missing data, allowing some control for language-family-specific tendencies.
library(tidyr)
library(mice)
setwd("~/Documents/Bristol/word2vec/word2vec_DPLACE/processing/")
l = read.csv("../data/FAIR_langauges_glotto_xdid.csv", stringsAsFactors = F)
eav = read.csv("../data/dplace-data-1.0/csv/EAVariableList.csv", stringsAsFactors = F)
ead = read.csv("../data/dplace-data-1.0/csv/EA_data.csv", stringsAsFactors = F)
# Load society data
eag = read.csv("../data/dplace-data-1.0/csv/xd_id_to_language.csv", stringsAsFactors = F)
eas = read.csv("../data/dplace-data-1.0/csv/EA_societies.csv")
# Proportion of missing data
sum(is.na(ead$Code))/nrow(ead)
# restrict societies to those in the facebook sample
#ead = ead[ead$soc_id %in% l$soc.id,]
#ead = ead[,!names(ead) %in% c("Dataset","SubCase",'Year','VarID_Code',"Comment","EthnoReferences","SourceCodedData","AdminComment")]
ead = ead[,c("soc_id", "VarID",  "Code")]
eadx = spread(data = ead, VarID, Code)
xid = eas[match(eadx$soc_id, eas$soc_id),]$xd_id
eadx$Family = eag[match(xid,eag$xd_id),]$FamilyGlottocode
# remove pop size
eadx = eadx[,names(eadx)!="202"]
numObs = apply(eadx,2,function(X){sum(!is.na(X))})
eadx = eadx[,names(eadx) %in% names(numObs[numObs>60])]
numLangs = apply(eadx,1,function(X){sum(is.na(X))})
eadx = eadx[numLangs<20,]
# missing data
sum(is.na(eadx[,2:(ncol(eadx)-1)])) / prod(dim(eadx[,2:ncol(eadx)]))
# Convert to factor
for(i in 2:ncol(eadx)){
eadx[,i] = as.factor(eadx[,i])
}
# eadx = eadx[sample(1:nrow(eadx),100),c(2,3,4,ncol(eadx))]
save(eadx, "../data/EA_imputed/preImputed.Rdat")
save(eadx, file="../data/EA_imputed/preImputed.Rdat")
rm(list=ls())
library(mice)
prop.missing = 0.05
load("../data/EA_imputed/preImputed.Rdat")
eadx.test = eadx
which(is.na(eadx.test),arr.ind = T)
nas = which(is.na(eadx),arr.ind = T)
test = cbind(sample(1:nrow(eadx)),
sample(1:ncol(eadx)))
eadx[,1]
n.na = prop.missing * prod(eadx[,2:ncol(eadx)])
n.na = prop.missing * prod(dim(eadx[,2:ncol(eadx)]))
n.na
n.na = round(prop.missing * prod(dim(eadx[,2:ncol(eadx)])))
n.na
dim(eadx)
prod(dim(eadx))
test
apply(test,1, function(X){X %in% nas})
duplicated
head(nas)
x= c(316,9)
duplicated(rbind(nas,x))
sum(duplicated(rbind(nas,x)))
test = matrix(nrow=n.na,ncol=2)
i = 1
while(i<n.na){
x = c(sample(1:nrow(eadx)),
sample(2:ncol(eadx)))
if(sum(duplicated(rbind(nas,x)))==0){
text[i,] = x
i = i + 1
}
}
x
test = matrix(nrow=n.na,ncol=2)
i = 1
while(i<n.na){
x = c(sample(1:nrow(eadx),1),
sample(2:ncol(eadx),1))
if(sum(duplicated(rbind(nas,x)))==0){
text[i,] = x
i = i + 1
}
}
x
test = matrix(nrow=n.na,ncol=2)
i = 1
while(i<n.na){
x = c(sample(1:nrow(eadx),1),
sample(2:ncol(eadx),1))
if(sum(duplicated(rbind(nas,x)))==0){
test[i,] = x
i = i + 1
}
}
tail(test)
x
duplicated(rbind(nas,x))
sum(duplicated(rbind(nas,x)))
sum(duplicated(rbind(nas,x)))==0
head(test)
i
test = cbind(sample(1:nrow(eadx)),
# don't take first column
sample(2:ncol(eadx)))
test = cbind(sample(1:nrow(eadx),n.na),
# don't take first column
sample(2:ncol(eadx),n.na))
nas
head(which(is.na(eadx),arr.ind = F))
head(which(is.na(eadx),arr.ind = T))
5732 /ncol(eadx)
5732 /nrow(eadx)
5732 %% ncol(eadx)
5732 %% nrow(eadx)
eadx[9]
n.test = round(prop.missing * prod(dim(eadx[,2:ncol(eadx)])))
idx = 1:prod(dim(eadx[,2:ncol(eadx)])))
nas = which(is.na(eadx),arr.ind = T)
idx = idx[!idx %in% nas]
test = sample(idx, n.test)
text.arrInd = cbind(test %% nrow(eadx),
ceil(text/(ncol(eadx)-1))+1)
rm(list=ls())
library(mice)
prop.missing = 0.05
load("../data/EA_imputed/preImputed.Rdat")
n.test = round(prop.missing * prod(dim(eadx[,2:ncol(eadx)])))
idx = 1:prod(dim(eadx[,2:ncol(eadx)]))
nas = which(is.na(eadx),arr.ind = T)
idx = idx[!idx %in% nas]
test = sample(idx, n.test)
head(test)
test.arrInd = cbind(test %% nrow(eadx),
ceil(text/(ncol(eadx)-1))+1)
test.arrInd = cbind(test %% nrow(eadx),
ceiling(text/(ncol(eadx)-1))+1)
test.arrInd = cbind(test %% nrow(eadx),
ceiling(test/(ncol(eadx)-1))+1)
head(test.arrInd)
dim(test.arrInd)
library(mice)
prop.missing = 0.05
load("../data/EA_imputed/preImputed.Rdat")
n.test = round(prop.missing * prod(dim(eadx[,2:ncol(eadx)])))
idx = 1:prod(dim(eadx[,2:ncol(eadx)]))
nas = which(is.na(eadx),arr.ind = T)
idx = idx[!idx %in% nas]
test = sample(idx, n.test)
test.arrInd = cbind(test %% nrow(eadx),
ceiling(test/(ncol(eadx)-1))+1)
# create new NAs
for(i in 1:nrow(test.arrInd)){
eadx[test.arrInd[i,1], test.arrInd[i,2]] = NA
}
library(mice)
prop.missing = 0.05
load("../data/EA_imputed/preImputed.Rdat")
n.test = round(prop.missing * prod(dim(eadx[,2:ncol(eadx)])))
idx = 1:prod(dim(eadx[,2:ncol(eadx)]))
nas = which(is.na(eadx),arr.ind = T)
idx = idx[!idx %in% nas]
test = sample(idx, n.test)
test.arrInd = cbind(test %% nrow(eadx),
ceiling(test/(ncol(eadx)-1))+1)
head(test.arrInd)
i = 1
nrow(test.arrInd)
eadx[test.arrInd[i,1], test.arrInd[i,2]]
test.arrInd[i,]
dim(eadx)
library(mice)
prop.missing = 0.05
load("../data/EA_imputed/preImputed.Rdat")
n.test = round(prop.missing * prod(dim(eadx[,2:ncol(eadx)])))
idx = 1:prod(dim(eadx[,2:ncol(eadx)]))
nas = which(is.na(eadx),arr.ind = F)
idx = idx[!idx %in% nas]
test = sample(idx, n.test)
test.arrInd = cbind(test %% nrow(eadx),
ceiling(test/(ncol(eadx)-1))+1)
for(i in 1:nrow(test.arrInd)){
eadx[test.arrInd[i,1], test.arrInd[i,2]] = NA
}
library(mice)
prop.missing = 0.05
load("../data/EA_imputed/preImputed.Rdat")
n.test = round(prop.missing * prod(dim(eadx[,2:ncol(eadx)])))
idx = 1:prod(dim(eadx[,2:ncol(eadx)]))
nas = which(is.na(eadx),arr.ind = F)
idx = idx[!idx %in% nas]
test = sample(idx, n.test)
test.arrInd = cbind(test %% nrow(eadx),
ceiling(test/(ncol(eadx)-1))+1)
head(test.arrInd)
1 %% 3
2 %% 3
3 %% 3
head(which(is.na(eadx),arr.ind = T))
head(which(is.na(eadx),arr.ind = F))
5732 %% nrow(eadx)
ceiling(5732/(ncol(eadx)-1))+1)
ceiling(5732/(ncol(eadx)-1))+1
5732 / nrow(eadx)
head(eadx)
eadx$soc_id
library(mice)
prop.missing = 0.025
load("../data/EA_imputed/preImputed.Rdat")
# take out socid
eadx = eadx[,-1]
n.test = round(prop.missing * prod(dim(eadx)))
n.test
?save
library(mice)
prop.missing = 0.025
load("../data/EA_imputed/preImputed.Rdat")
# take out socid
eadx = eadx[,-1]
n.test = round(prop.missing * prod(dim(eadx)))
idx = 1:prod(dim(eadx))
nas = which(is.na(eadx),arr.ind = F)
idx = idx[!idx %in% nas]
test = sample(idx, n.test)
test.arrInd = cbind(test %% nrow(eadx),
ceiling(test/(nrow(eadx))))
# create new NAs
for(i in 1:nrow(test.arrInd)){
eadx[test.arrInd[i,1], test.arrInd[i,2]] = NA
}
eadx.imputed = mice(data = eadx,
m=1, method='cart')
eadx.imputed = mice(data = eadx[,10:11],
m=1, method='cart')
eadx2 = complete(eadx.imputed, 1)
save(eadx2,test.arrInd, file=paste0("../results/imputationTests/imputeTest_",sample(1:9999999,1),".rDat"))
rm(list=ls())
load('../results/imputationTests/imputeTest_8753094.rDat')
ls
ls()
head(eadx2)
sum(is.na(eadx2))
?
library(mice)
prop.missing = 0.025
load("../data/EA_imputed/preImputed.Rdat")
# take out socid
eadx = eadx[,-1]
sum(is.na(eadx))
n.test = round(prop.missing * prod(dim(eadx)))
idx = 1:prod(dim(eadx))
nas = which(is.na(eadx),arr.ind = F)
idx = idx[!idx %in% nas]
test = sample(idx, n.test)
test.arrInd = cbind(test %% nrow(eadx),
ceiling(test/(nrow(eadx))))
# create new NAs
for(i in 1:nrow(test.arrInd)){
eadx[test.arrInd[i,1], test.arrInd[i,2]] = NA
}
sum(is.na(eadx))

---
title: "Cultural distances: Wikipedia data"
output: 
  pdf_document:
    toc: true
---

```{r echo=F, eval=F}
setwd("~/Documents/Bristol/word2vec/word2vec_DPLACE/analysis/")
```

# Introduction

We compare cultural distances between socieites with linguistic similarities between societies, controlling for shared history in two ways.

The first test uses mixed effects modelling.  The pairing of the language family of each language (according to Glottolog) is used as a random effect.  That means that the model can capture the likelihood that two languages from the Indo-European language family will be more similar to each other than two languages from different language families.  The same is done with geographic area according to Autotyp.

The second test controls for history using distances from a phylogenetic tree.  The tree comes from Bouckaert et al. (2012).  Patristic distances between languages are used as a measure of historical distance between societies in a Mantel test.  Note that the Mantel test assumes a strict distance metric, which is not necessarily the case with this data, but there are few other ways to deal with continuous pairwise distances. 

# Load libraries
```{r warning=F, message=F}
library(ape)
library(ecodist)
library(lme4)
library(sjPlot)
library(ggplot2)
library(igraph)
library(lattice)
```

Parameters (using data from Northuralex and Wikipedia, k=100, unfiltered):

```{r}
datasetName = "wikipedia-main"
lingDistancesFile = "../data/FAIR/nel-wiki-k100-alignments-by-language-pair.csv"
lingDistancesFileNK = "../data/FAIR/nel-wiki-k100-alignments-by-language-pair-without-kinship.csv"
lingDistancesByDomainFile = "../results/EA_distances/nel-wiki-k100_with_ling.csv"
# (generated by ../processing/combineCultAndLingDistances.R)
```

\newpage


# All domains

## Load data

Read the cultural distances:

```{r}
cult = read.csv("../results/EA_distances/CulturalDistances_Long.csv", stringsAsFactors = F)
names(cult) = c("l1","l2","cult.dist")
cultLangs = unique(c(cult$Var1,cult$Var2))
```

Add language family:

```{r}
l = read.csv("../data/FAIR_langauges_glotto_xdid.csv", stringsAsFactors = F)
g = read.csv("../data/glottolog-languoid.csv/languoid.csv", stringsAsFactors = F)
l$family = g[match(l$glotto,g$id),]$family_pk
l$family = g[match(l$family,g$pk),]$name
```

Read the semantic distances

```{r}
ling = read.csv(lingDistancesFile, stringsAsFactors = F)
```

There are very few possible comparisons for Slovenian and Northern Sami, so we'll remove these:

```{r}
ling = ling[!(ling$l1=="se" || ling$l2 == "se"),]
ling = ling[!(ling$l1=="sl" || ling$l2 == "sl"),]
```


Combine the lingusitic and cultural distances. Note that we flip the cultural measure from a distance measure to a similarity measure.

```{r}
cult$l1.iso2 = l[match(cult$l1,l$Language2),]$iso2
cult$l2.iso2 = l[match(cult$l2,l$Language2),]$iso2

fairisos = unique(c(ling$l1,ling$l2))
cultisos = unique(c(cult$l1.iso2, cult$l2.iso2))

cult = cult[(cult$l1.iso2 %in% fairisos) & (cult$l2.iso2 %in% fairisos),]
ling = ling[(ling$l1 %in% cultisos) & (ling$l2 %in% cultisos),]

matches = sapply(1:nrow(ling), function(i){
  which(cult$l1.iso2==ling$l1[i] & cult$l2.iso2==ling$l2[i])
})

ling$cult.dist = cult[matches,]$cult.dist
# Flip
ling$cult.dist = 1 - ling$cult.dist
# Scale
ling$cult.dist.center = scale(ling$cult.dist)
cdc.s = attr(ling$cult.dist.center,"scaled:scale")
cdc.c = attr(ling$cult.dist.center,"scaled:center")
ling$cult.dist.center = as.numeric(ling$cult.dist.center)
ling$comparison_count.center = 
  scale(ling$comparison_count)

ling$family1 = l[match(ling$l1, l$iso2),]$family
ling$family2 = l[match(ling$l2, l$iso2),]$family
ling$area1 = l[match(ling$l1, l$iso2),]$autotyp.area
ling$area2 = l[match(ling$l2, l$iso2),]$autotyp.area


fgroup = cbind(ling$family1,ling$family2)
fgroup = apply(fgroup,1,sort)
ling$family.group = apply(fgroup,2,paste,collapse=":")
agroup = cbind(ling$area1,ling$area2)
agroup = apply(agroup,1,sort)
ling$area.group = apply(agroup,2,paste,collapse=":")

ling$rho.center = scale(ling$local_alignment)

```

Each observation is now assocaited with a language family pair:

```{r}
head(ling[,c("l1","l2","local_alignment",'family.group')])
```

And the same is true for area:

```{r}
tail(ling[,c("l1","l2","local_alignment",'area.group')])
```

Number of observations:

```{r}
# Number of datapoints:
nrow(ling)
# Number of unique languages:
length(unique(unlist(ling[,c("l1","l2")])))
# Number of unique langauge families:
uniqueFamilies = unique(unlist(ling[,c("family1","family2")]))
length(uniqueFamilies)
# Number of unique areas:
uniqueAreas = unique(unlist(ling[,c("area1","area2")]))
length(uniqueAreas)
```

Cross-over between language famlies and areas:

```{r}
tx = data.frame(lang= c(ling$l1,ling$l2),
           fam = c(ling$family1,ling$family2),
           area= c(ling$area1,ling$area2))
tx = tx[!duplicated(tx),]
table(tx$fam,tx$area)
```


\newpage

## LMER models

Mixed effects model, predicting Linguistic similaritys from cultural similarity, with random intercept for family and area and random slope for cultural similarity for family and area.

We start with a null model with random intercepts for family and area, and random slopes for cultural similarity by both. We add a fixed effect of the number of comparisons made for each datapoint (number of concepts that were available to compare). Then we add a fixed effect of cultural similarity

```{r}
m0 = lmer(
  rho.center ~ 1 +
    (1 + cult.dist.center | family.group) +
    (1 + cult.dist.center | area.group),
  data = ling
)
m0.5 = lmer(
  rho.center ~ 1 +
    comparison_count.center +
    (1 + cult.dist.center | family.group) +
    (1 + cult.dist.center | area.group),
  data = ling
)
m1 = lmer(
  rho.center ~ 1 +
    comparison_count.center +
    cult.dist.center +
    (1 + cult.dist.center | family.group) +
    (1 + cult.dist.center | area.group),
  data = ling
)
anova(m0,m0.5,m1)
```

Cultural similarity is significantly correlated with Linguistic similarity.  Here are the model estimates:

```{r}
summary(m1)
```

Plot the estimates, rescaling the variables back to the original units:

```{r}
gx = sjp.lmer(m1,'pred','cult.dist.center', 
              prnt.plot = F)
gx$plot$data$y = gx$plot$data$y *
  attr(ling$rho.center,"scaled:scale") +
  attr(ling$rho.center,"scaled:center")
gx$plot$data$resp.y = gx$plot$data$resp.y *
  attr(ling$rho.center,"scaled:scale") +
  attr(ling$rho.center,"scaled:center")
gx$plot$data$x = gx$plot$data$x *
  cdc.s +cdc.c
gx = gx$plot + coord_cartesian(ylim=c(-0.05,0.5),
                          xlim=c(0.15,0.85)) +
  xlab("Cultural similarity") +
  ylab("Semantic alignment") +
  ggtitle("")
gx
pdf(paste0("../results/stats/",datasetName,"/CulturalDistance_Rho_Graph.pdf"),
    height=2.5, width=2.5)
gx
dev.off()
```

Plot the random effects:

```{r}
sjp.lmer(m1,'re', sort.est = "cult.dist.center")
px = sjp.lmer(m1,'rs.ri', prnt.plot = F)
dx = px$plot[[1]]$data
dx$x = dx$x * cdc.s + cdc.c
dx$y = dx$y * 
  attr(ling$rho.center,"scaled:scale") +
  attr(ling$rho.center,"scaled:center")
ggplot(dx,aes(x,y)) +
  geom_point(data=ling, 
             mapping=aes(x=as.numeric(cult.dist),
                         y=as.numeric(local_alignment))) +
  geom_line(mapping = aes(colour=grp)) +
  xlab("Cultural similarity")+
  ylab("Linguistic similarity") +
  ggtitle("Language family pair random effects") +
  coord_cartesian(ylim=c(0.1,0.6),
                  xlim=c(0.2,0.8)) + 
  theme(legend.position = "none")

dx = px$plot[[2]]$data
dx$x = dx$x * cdc.s + cdc.c
dx$y = dx$y * 
  attr(ling$rho.center,"scaled:scale") +
  attr(ling$rho.center,"scaled:center")
ggplot(dx,aes(x,y)) +
  geom_point(data=ling, 
             mapping=aes(x=as.numeric(cult.dist),
                         y=as.numeric(local_alignment))) +
  geom_line(mapping = aes(colour=grp)) +
  xlab("Cultural similarity")+
  ylab("Linguistic similarity") +
  ggtitle("Area pair random effects") +
  coord_cartesian(ylim=c(0.1,0.6),
                  xlim=c(0.2,0.8))
```

\newpage

## Without Kinship data

The analyses below show that the strongest relationship is with Kinship.  Here we run the analysis as above, but using semantic distances computed without concepts that relate to kinship.  Code for constructing the data is hidden, but it is the same as above and available in the Rmd file:

```{r echo=F,warning=F}

lingNK = read.csv(lingDistancesFileNK, stringsAsFactors = F)
lingNK = lingNK[!(lingNK$l1=="se" || lingNK$l2 == "se"),]
lingNK = lingNK[!(lingNK$l1=="sl" || lingNK$l2 == "sl"),]

lingNK = ling[(ling$l1 %in% cultisos) & (ling$l2 %in% cultisos),]

matchesNK = sapply(1:nrow(lingNK), function(i){
which(cult$l1.iso2==lingNK$l1[i] & cult$l2.iso2==lingNK$l2[i])
})

lingNK$cult.dist = cult[matches,]$cult.dist
# Flip
lingNK$cult.dist = 1 - lingNK$cult.dist
# Scale
lingNK$cult.dist.center = scale(lingNK$cult.dist)
cdc.sNK = attr(lingNK$cult.dist.center,"scaled:scale")
cdc.cNK = attr(lingNK$cult.dist.center,"scaled:center")
lingNK$cult.dist.center = as.numeric(lingNK$cult.dist.center)
lingNK$comparison_count.center = 
scale(lingNK$comparison_count)

lingNK$family1 = l[match(lingNK$l1, l$iso2),]$family
lingNK$family2 = l[match(lingNK$l2, l$iso2),]$family
lingNK$area1 = l[match(lingNK$l1, l$iso2),]$autotyp.area
lingNK$area2 = l[match(lingNK$l2, l$iso2),]$autotyp.area


fgroupNK = cbind(lingNK$family1,lingNK$family2)
fgroupNK = apply(fgroupNK,1,sort)
lingNK$family.group = apply(fgroupNK,2,paste,collapse=":")
agroupNK = cbind(lingNK$area1,lingNK$area2)
agroupNK = apply(agroupNK,1,sort)
lingNK$area.group = apply(agroupNK,2,paste,collapse=":")

lingNK$rho.center = scale(ling$local_alignment)
```

Run the lmer models:

```{r}
m0NK = lmer(
  rho.center ~ 1 +
    (1 + cult.dist.center | family.group) +
    (1 + cult.dist.center | area.group),
  data = lingNK
)
m0.5NK = lmer(
  rho.center ~ 1 +
    comparison_count.center +
    (1 + cult.dist.center | family.group) +
    (1 + cult.dist.center | area.group),
  data = lingNK
)
m1NK = lmer(
  rho.center ~ 1 +
    comparison_count.center +
    cult.dist.center +
    (1 + cult.dist.center | family.group) +
    (1 + cult.dist.center | area.group),
  data = lingNK
)
anova(m0NK,m0.5NK,m1NK)
summary(m1NK)
```








\newpage

# Tests within domains

## Load data

Load distances for specific domains and match up to language family and area:

```{r withinDomains}
ling.dom = read.csv(
  lingDistancesByDomainFile, 
  stringsAsFactors = F)

ling.dom = ling.dom[!is.na(ling.dom$cult.dist),]

ling.dom = ling.dom[(ling.dom$l1 %in% cultisos) & 
                      (ling.dom$l2 %in% cultisos),]
```

There are very few possible comparisons for Slovenian and Northern Sami, so we'll remove these:

```{r}
ling.dom = ling.dom[!(ling.dom$l1=="se" || ling.dom$l2 == "se"),]
ling.dom = ling.dom[!(ling.dom$l1=="sl" || ling.dom$l2 == "sl"),]
```

Match family and area data:

```{r}
ling.dom$family1 = l[match(ling.dom$l1, l$iso2),]$family
ling.dom$family2 = l[match(ling.dom$l2, l$iso2),]$family
ling.dom$area1 = l[match(ling.dom$l1, l$iso2),]$autotyp.area
ling.dom$area2 = l[match(ling.dom$l2, l$iso2),]$autotyp.area


# Paste language family names together,
# but order shouldn't matter, so sort first
fgroup = cbind(ling.dom$family1,ling.dom$family2)
fgroup = apply(fgroup,1,sort)
ling.dom$family.group = apply(fgroup,2,paste,collapse=":")

agroup = cbind(ling.dom$area1,ling.dom$area2)
agroup = apply(agroup,1,sort)
ling.dom$area.group = apply(agroup,2,paste,collapse=":")
```

Center the data (and flip cultural distance into cultural similarity):

```{r}
ling.dom$cult.dist = 1-ling.dom$cult.dist
ling.dom$cult.dist.center = scale(ling.dom$cult.dist)
ling.dom$rho.center = scale(ling.dom$local_alignment)
ling.dom$comparison_count.center = scale(ling.dom$comparison_count)
```

## LMER models

Test whether random slopes are warraneted for family:

```{r}
mD0 = lmer(
  rho.center ~ 1 +
    comparison_count.center +
    (1 | family.group) +
    (1 | area.group) +
    (1 | imputed_semantic_domain),
  data = ling.dom)
mD1 = lmer(
  rho.center ~ 1 +
    comparison_count.center +
    (1 | family.group) +
    (0 + cult.dist.center | family.group) +
    (1 | area.group) +
    (1 | imputed_semantic_domain),
  data = ling.dom)
mD2 = lmer(
  rho.center ~ 1 +
    comparison_count.center +
    (1 + cult.dist.center | family.group) +
    (1 | area.group) +
    (1 | imputed_semantic_domain),
  data = ling.dom)
anova(mD0,mD1,mD2)
```

Random slopes (and the correlation coefficient) for family improves the fit of the model.

Test the same for area:

```{r}
mD3 = lmer(
  rho.center ~ 1 +
    comparison_count.center +
    (1 + cult.dist.center | family.group) +
    (1 + cult.dist.center | area.group) +
    (1 | imputed_semantic_domain),
  data = ling.dom)
anova(mD2,mD3)
```

Random slopes for area improves the fit of the model.


Test random slopes for domain:

```{r}
mdom1 = lmer(
  rho.center ~ 1 +
    comparison_count.center +
    (1 +cult.dist.center| family.group) +
    (1 +cult.dist.center| area.group) +
    (1 | imputed_semantic_domain),
  data = ling.dom)
mdom2 = lmer(
  rho.center ~ 1 +
    comparison_count.center +
    (1 +cult.dist.center| family.group) +
    (1 +cult.dist.center| area.group) +
    (1 +cult.dist.center| imputed_semantic_domain),
  data = ling.dom)
anova(mdom1,mdom2)
```

Random slope for domains significantly improves model.

Now we test the main effect of cultural similarity:

```{r}
mD5 = lmer(
  rho.center ~ 1 +
    comparison_count.center +
    (1 + cult.dist.center | family.group) +
    (1 + cult.dist.center | area.group) +
    (1 + cult.dist.center | imputed_semantic_domain),
  data = ling.dom)
mD6 = update(mD5, ~.+cult.dist.center)
anova(mD5,mD6)
```

Summary of the final model, with random effects plot:

```{r}
summary(mD6)
dotplot(ranef(mD6))
```

\newpage

Plot the predicted relationships for each domain.  The domains in the legend are sorted by the slope for cultural similarity (greatest negative slope to greatest positive slope):

```{r}
sjp.lmer(mD6,'eff', show.ci = T)
dom.order = ranef(mD6)$imputed_semantic_domain
dom.order = rownames(dom.order[order(dom.order$cult.dist.center),])
px = sjp.lmer(mD6,'rs.ri', show.ci = T, prnt.plot = F)
pdx = px$plot[[3]]$data
pdx$Domain = factor(pdx$grp, levels = dom.order)
pdx$x = pdx$x *
  attr(ling.dom$cult.dist.center,"scaled:scale") +
  attr(ling.dom$cult.dist.center,"scaled:center")
pdx$y = pdx$y *
  attr(ling.dom$rho.center,"scaled:scale") +
  attr(ling.dom$rho.center,"scaled:center")
ggplot(pdx,
       aes(x,y,colour=Domain)) +
  geom_line() +
  xlab("Cultural Similarity") +
  ylab("Linguistic similarity")

```

Overall slope estimate for each domain:

```{r}
ref.slopes.dom = data.frame(
  domain = rownames(ranef(mD6)$imputed_semantic_domain),
  slope = (fixef(mD6)["cult.dist.center"] +
  ranef(mD6)$imputed_semantic_domain[,2]))
ref.slopes.dom[order(ref.slopes.dom$slope),]
```

\newpage

## Are the relevant D-place features most predictive?

Long format to line up comparisons:

```{r}
ling.dom.wide = ling.dom[,c("l1",'l2',
            'imputed_semantic_domain',
            "local_alignment","cult.dist")]
ling.dom.wide = reshape(ling.dom.wide, 
                        idvar = c("l1","l2"), 
                        timevar = "imputed_semantic_domain",
                        direction = "wide")
ling.dom.wide = cbind(ling.dom.wide[,1:2],
                      ling.dom.wide[,3:ncol(ling.dom.wide)][
                        order(names(ling.dom.wide[,3:ncol(ling.dom.wide)]))
                      ])
snames = c("Agri","Tech","Emot","Kin","Poss","Soc","Hous","Wrld")
names(ling.dom.wide) = c("l1","l2",
                         paste0("L.",snames),
                         paste0("C.",snames))
```

Raw correlation between each pair of domains

```{r}
compareAllDomains = 
  cor(ling.dom.wide[,
      grepl("L\\.",names(ling.dom.wide))],
    ling.dom.wide[,
      grepl("C\\.",names(ling.dom.wide))],
    use="complete.obs")

round(compareAllDomains,2)
```

\newpage

# Mantel tests

Read the historical distances for Indo-European, based on the phylogenetic distances.

## Data prep

Load historical distances:

```{r}
hist = read.csv("../data/trees/IndoEuropean_historical_distances.csv", stringsAsFactors = F)
hist = hist[!duplicated(hist[,1]),!duplicated(hist[,1])]
rownames(hist) = hist[,1]
hist = hist[,2:ncol(hist)]
hist.m = as.matrix(hist)
colnames(hist.m) = rownames(hist.m)
hist.m = hist.m/max(hist.m)
```

Read the cultural distance as a matrix:

```{r}
cult.m = read.csv("../results/EA_distances/CulturalDistances.csv", stringsAsFactors = F)
rownames(cult.m) = cult.m[,1]
cult.m = cult.m[,2:ncol(cult.m)]
```

Flip the cultural distance into a cultural similarity measure:

```{r}
cult.m = 1-cult.m
```

Convert the linguistic similarities to a matrix.  This uses `igraph` to make an undirected graph from the long format with `local_alignment` as the edge weights, then output a matrix of adjacencies.

```{r}
grph <- graph.data.frame(ling[,c("l1",'l2','local_alignment')], directed=FALSE)
# add value as a weight attribute
ling.m = get.adjacency(grph, attr="local_alignment", sparse=FALSE)
rownames(ling.m) = l[match(rownames(ling.m),l$iso2),]$Language2
colnames(ling.m) = l[match(colnames(ling.m),l$iso2),]$Language2
```

Load the geographic distances:

```{r}
geoDist = read.csv("../data/GeographicDistances.csv",stringsAsFactors = F)
geoDist.m = as.matrix(geoDist)
# Convert to log distance
geoDist.m = log(geoDist.m)
geoDist.m[is.infinite(geoDist.m)] = 0
rownames(geoDist.m) = colnames(geoDist.m)
```



Match the distance matrices

```{r}
in.analysis = intersect(rownames(ling.m),rownames(cult.m))
in.analysis = intersect(in.analysis, rownames(hist.m))
cult.m2 = cult.m[in.analysis,in.analysis]
ling.m2 = ling.m[in.analysis,in.analysis]
hist.m2 = hist.m[in.analysis,in.analysis]
geo.m2 = geoDist.m[in.analysis,in.analysis]
```

Note that there are only `r length(in.analysis)` languages with data on lingusitic, cultural and historical distance.

```{r}
plot(as.dist(cult.m2),as.dist(ling.m2),
     xlab="Cultural similarity",
     ylab="Linguistic similarity")
plot(as.dist(cult.m2),as.dist(hist.m2),
     xlab="Cultural similarity",
     ylab="Historical distance")
plot(as.dist(ling.m2),as.dist(hist.m2),
     xlab="Linguistic similarity",
     ylab="Historical distance")
```


## Tests

The results of the test list the following measures:

-  mantelr: Mantel correlation coefficient.
-  pval1: one-tailed p-value (null hypothesis: r <= 0).
-  pval2: one-tailed p-value (null hypothesis: r >= 0).
-  pval3: two-tailed p-value (null hypothesis: r = 0).
-  llim: lower confidence limit for r.
-  ulim: upper confidence limit for r.

```{r}
set.seed(1498)
```

```{r}
distms = list("Cultrual"= cult.m2,
              "Linguistic" = ling.m2,
              "Historical" = hist.m2,
              "Geographic" = geo.m2)
for(i in 1:3){
  for(j in (i+1):4){
    print(paste("Correlation between",
                names(distms)[i],"and",names(distms)[j]))
    print(ecodist::mantel(as.dist(distms[[i]]) ~
                as.dist(distms[[j]]),
                nperm = 100000))
  }
}
```



Run a mantel test comparing the Linguistic alignment to the cultural similarity, controlling for the historical distance between languages:

```{r}
ecodist::mantel(as.dist(ling.m2)~
                  as.dist(cult.m2) + 
                  as.dist(hist.m2),
                nperm = 100000)
```

*Main Test*: Run a mantel test comparing the Linguistic alignment to the cultural similarity, controlling for the historical distance and geographic distance between languages:

```{r}
ecodist::mantel(as.dist(ling.m2)~
                  as.dist(cult.m2) + 
                  as.dist(hist.m2) +
                  as.dist(geo.m2),
                nperm = 100000)
```



\newpage





# References

Bouckaert, Remco, Philippe Lemey, Michael Dunn, Simon J. Greenhill, Alexander V. Alekseyenko, Alexei J. Drummond, Russell D. Gray, Marc A. Suchard, and Quentin D. Atkinson (2012). Mapping the origins and expansion of the Indo-European language family. Science, 337(6097), 957-960.
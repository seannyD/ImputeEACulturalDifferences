colnames(hist.m) = rownames(hist.m)
hist.m = hist.m/max(hist.m)
```
Read the cultural distance as a matrix:
```{r}
cult.m = read.csv("../results/EA_distances/CulturalDistances.csv", stringsAsFactors = F)
rownames(cult.m) = cult.m[,1]
cult.m = cult.m[,2:ncol(cult.m)]
```
Flip the cultural distance into a cultural similarity measure:
```{r}
cult.m = 1-cult.m
```
Convert the linguistic similarities to a matrix.  This uses `igraph` to make an undirected graph from the long format with `local_alignment` as the edge weights, then output a matrix of adjacencies.
```{r}
grph <- graph.data.frame(ling[,c("l1",'l2','local_alignment')], directed=FALSE)
# add value as a weight attribute
ling.m = get.adjacency(grph, attr="local_alignment", sparse=FALSE)
rownames(ling.m) = l[match(rownames(ling.m),l$iso2),]$Language2
colnames(ling.m) = l[match(colnames(ling.m),l$iso2),]$Language2
```
Load the geographic distances:
```{r}
geoDist = read.csv("../data/GeographicDistances.csv",stringsAsFactors = F)
geoDist.m = as.matrix(geoDist)
# Convert to log distance
geoDist.m = log(geoDist.m)
geoDist.m[is.infinite(geoDist.m)] = 0
rownames(geoDist.m) = colnames(geoDist.m)
```
Match the distance matrices
```{r}
in.analysis = intersect(rownames(ling.m),rownames(cult.m))
in.analysis = intersect(in.analysis, rownames(hist.m))
cult.m2 = cult.m[in.analysis,in.analysis]
ling.m2 = ling.m[in.analysis,in.analysis]
hist.m2 = hist.m[in.analysis,in.analysis]
geo.m2 = geoDist.m[in.analysis,in.analysis]
```
Note that there are only `r length(in.analysis)` languages with data on lingusitic, cultural and historical distance.
```{r}
plot(as.dist(cult.m2),as.dist(ling.m2),
xlab="Cultural similarity",
ylab="Linguistic similarity")
plot(as.dist(cult.m2),as.dist(hist.m2),
xlab="Cultural similarity",
ylab="Historical distance")
plot(as.dist(ling.m2),as.dist(hist.m2),
xlab="Linguistic similarity",
ylab="Historical distance")
```
```{r warning=F,echo=F}
t = read.nexus("../data/trees/bouckaert_et_al2012-d-place_2.NEXUS")
treenames = read.csv("../data/trees/taxa.csv", stringsAsFactors = F)
# These are not necessarily the right glottocode, but they do link the right data
treenames[treenames$taxon=="Albanian_G",]$glottocode = "gheg1238"
treenames[treenames$taxon=="Greek_Mod",]$glottocode = "mode1248"
# convert tip labels to glotto codes
t$tip.label = treenames[match(t$tip.label,treenames$taxon),]$glottocode
t2 = drop.tip(t,t$tip.label[!t$tip.label %in% l[match(in.analysis,l$Language),]$glotto])
t2$tip.label = l[match(t2$tip.label,l$glotto),]$Language
plot(t2)
```
library(ape)
library(ecodist)
library(lme4)
library(sjPlot)
library(ggplot2)
library(igraph)
library(lattice)
hist = read.csv("../data/trees/IndoEuropean_historical_distances.csv", stringsAsFactors = F)
hist = hist[!duplicated(hist[,1]),!duplicated(hist[,1])]
rownames(hist) = hist[,1]
hist = hist[,2:ncol(hist)]
hist.m = as.matrix(hist)
colnames(hist.m) = rownames(hist.m)
hist.m = hist.m/max(hist.m)
```
Read the cultural distance as a matrix:
```{r}
cult.m = read.csv("../results/EA_distances/CulturalDistances.csv", stringsAsFactors = F)
rownames(cult.m) = cult.m[,1]
cult.m = cult.m[,2:ncol(cult.m)]
```
Flip the cultural distance into a cultural similarity measure:
```{r}
cult.m = 1-cult.m
```
Convert the linguistic similarities to a matrix.  This uses `igraph` to make an undirected graph from the long format with `local_alignment` as the edge weights, then output a matrix of adjacencies.
```{r}
grph <- graph.data.frame(ling[,c("l1",'l2','local_alignment')], directed=FALSE)
# add value as a weight attribute
ling.m = get.adjacency(grph, attr="local_alignment", sparse=FALSE)
rownames(ling.m) = l[match(rownames(ling.m),l$iso2),]$Language2
colnames(ling.m) = l[match(colnames(ling.m),l$iso2),]$Language2
```
Load the geographic distances:
```{r}
geoDist = read.csv("../data/GeographicDistances.csv",stringsAsFactors = F)
geoDist.m = as.matrix(geoDist)
# Convert to log distance
geoDist.m = log(geoDist.m)
geoDist.m[is.infinite(geoDist.m)] = 0
rownames(geoDist.m) = colnames(geoDist.m)
```
Match the distance matrices
```{r}
in.analysis = intersect(rownames(ling.m),rownames(cult.m))
in.analysis = intersect(in.analysis, rownames(hist.m))
cult.m2 = cult.m[in.analysis,in.analysis]
ling.m2 = ling.m[in.analysis,in.analysis]
hist.m2 = hist.m[in.analysis,in.analysis]
geo.m2 = geoDist.m[in.analysis,in.analysis]
```
Note that there are only `r length(in.analysis)` languages with data on lingusitic, cultural and historical distance.
```{r}
plot(as.dist(cult.m2),as.dist(ling.m2),
xlab="Cultural similarity",
ylab="Linguistic similarity")
plot(as.dist(cult.m2),as.dist(hist.m2),
xlab="Cultural similarity",
ylab="Historical distance")
plot(as.dist(ling.m2),as.dist(hist.m2),
xlab="Linguistic similarity",
ylab="Historical distance")
```
```{r warning=F,echo=F}
t = read.nexus("../data/trees/bouckaert_et_al2012-d-place_2.NEXUS")
treenames = read.csv("../data/trees/taxa.csv", stringsAsFactors = F)
# These are not necessarily the right glottocode, but they do link the right data
treenames[treenames$taxon=="Albanian_G",]$glottocode = "gheg1238"
treenames[treenames$taxon=="Greek_Mod",]$glottocode = "mode1248"
# convert tip labels to glotto codes
t$tip.label = treenames[match(t$tip.label,treenames$taxon),]$glottocode
t2 = drop.tip(t,t$tip.label[!t$tip.label %in% l[match(in.analysis,l$Language),]$glotto])
t2$tip.label = l[match(t2$tip.label,l$glotto),]$Language
plot(t2)
```
---
title: "Cultural distances: Wikipedia data"
output:
pdf_document:
toc: true
---
```{r echo=F, eval=F}
setwd("~/Documents/Bristol/word2vec/word2vec_DPLACE/analysis/")
```
# Introduction
We compare cultural distances between socieites with linguistic similarities between societies, controlling for shared history in two ways.
The first test uses mixed effects modelling.  The pairing of the language family of each language (according to Glottolog) is used as a random effect.  That means that the model can capture the likelihood that two languages from the Indo-European language family will be more similar to each other than two languages from different language families.  The same is done with geographic area according to Autotyp.
The second test controls for history using distances from a phylogenetic tree.  The tree comes from Bouckaert et al. (2012).  Patristic distances between languages are used as a measure of historical distance between societies in a Mantel test.  Note that the Mantel test assumes a strict distance metric, which is not necessarily the case with this data, but there are few other ways to deal with continuous pairwise distances.
# Load libraries
```{r warning=F, message=F}
library(ape)
library(ecodist)
library(lme4)
library(sjPlot)
library(ggplot2)
library(igraph)
library(lattice)
```
Parameters (using data from Northuralex and Wikipedia, k=100, unfiltered):
```{r}
datasetName = "wikipedia-main"
lingDistancesFile = "../data/FAIR/nel-wiki-k100-alignments-by-language-pair.csv"
lingDistancesFileNK = "../data/FAIR/nel-wiki-k100-alignments-by-language-pair-without-kinship.csv"
lingDistancesByDomainFile = "../results/EA_distances/nel-wiki-k100_with_ling.csv"
# (generated by ../processing/combineCultAndLingDistances.R)
```
\newpage
# All domains
## Load data
Read the cultural distances:
```{r}
cult = read.csv("../results/EA_distances/CulturalDistances_Long.csv", stringsAsFactors = F)
names(cult) = c("l1","l2","cult.dist")
cultLangs = unique(c(cult$Var1,cult$Var2))
```
Add language family:
```{r}
l = read.csv("../data/FAIR_langauges_glotto_xdid.csv", stringsAsFactors = F)
g = read.csv("../data/glottolog-languoid.csv/languoid.csv", stringsAsFactors = F)
l$family = g[match(l$glotto,g$id),]$family_pk
l$family = g[match(l$family,g$pk),]$name
```
Read the semantic distances
```{r}
ling = read.csv(lingDistancesFile, stringsAsFactors = F)
```
There are very few possible comparisons for Slovenian and Northern Sami, so we'll remove these:
```{r}
ling = ling[!(ling$l1=="se" || ling$l2 == "se"),]
ling = ling[!(ling$l1=="sl" || ling$l2 == "sl"),]
```
Combine the lingusitic and cultural distances. Note that we flip the cultural measure from a distance measure to a similarity measure.
```{r}
cult$l1.iso2 = l[match(cult$l1,l$Language2),]$iso2
cult$l2.iso2 = l[match(cult$l2,l$Language2),]$iso2
fairisos = unique(c(ling$l1,ling$l2))
cultisos = unique(c(cult$l1.iso2, cult$l2.iso2))
cult = cult[(cult$l1.iso2 %in% fairisos) & (cult$l2.iso2 %in% fairisos),]
ling = ling[(ling$l1 %in% cultisos) & (ling$l2 %in% cultisos),]
matches = sapply(1:nrow(ling), function(i){
which(cult$l1.iso2==ling$l1[i] & cult$l2.iso2==ling$l2[i])
})
ling$cult.dist = cult[matches,]$cult.dist
# Flip
ling$cult.dist = 1 - ling$cult.dist
# Scale
ling$cult.dist.center = scale(ling$cult.dist)
cdc.s = attr(ling$cult.dist.center,"scaled:scale")
cdc.c = attr(ling$cult.dist.center,"scaled:center")
ling$cult.dist.center = as.numeric(ling$cult.dist.center)
ling$comparison_count.center =
scale(ling$comparison_count)
ling$family1 = l[match(ling$l1, l$iso2),]$family
ling$family2 = l[match(ling$l2, l$iso2),]$family
ling$area1 = l[match(ling$l1, l$iso2),]$autotyp.area
ling$area2 = l[match(ling$l2, l$iso2),]$autotyp.area
fgroup = cbind(ling$family1,ling$family2)
fgroup = apply(fgroup,1,sort)
ling$family.group = apply(fgroup,2,paste,collapse=":")
agroup = cbind(ling$area1,ling$area2)
agroup = apply(agroup,1,sort)
ling$area.group = apply(agroup,2,paste,collapse=":")
ling$rho.center = scale(ling$local_alignment)
```
Each observation is now assocaited with a language family pair:
```{r}
head(ling[,c("l1","l2","local_alignment",'family.group')])
```
And the same is true for area:
```{r}
tail(ling[,c("l1","l2","local_alignment",'area.group')])
```
Number of observations:
```{r}
# Number of datapoints:
nrow(ling)
# Number of unique languages:
length(unique(unlist(ling[,c("l1","l2")])))
# Number of unique langauge families:
uniqueFamilies = unique(unlist(ling[,c("family1","family2")]))
length(uniqueFamilies)
# Number of unique areas:
uniqueAreas = unique(unlist(ling[,c("area1","area2")]))
length(uniqueAreas)
```
Cross-over between language famlies and areas:
```{r}
tx = data.frame(lang= c(ling$l1,ling$l2),
fam = c(ling$family1,ling$family2),
area= c(ling$area1,ling$area2))
tx = tx[!duplicated(tx),]
table(tx$fam,tx$area)
```
hist = read.csv("../data/trees/IndoEuropean_historical_distances.csv", stringsAsFactors = F)
hist = hist[!duplicated(hist[,1]),!duplicated(hist[,1])]
rownames(hist) = hist[,1]
hist = hist[,2:ncol(hist)]
hist.m = as.matrix(hist)
colnames(hist.m) = rownames(hist.m)
hist.m = hist.m/max(hist.m)
```
Read the cultural distance as a matrix:
```{r}
cult.m = read.csv("../results/EA_distances/CulturalDistances.csv", stringsAsFactors = F)
rownames(cult.m) = cult.m[,1]
cult.m = cult.m[,2:ncol(cult.m)]
```
Flip the cultural distance into a cultural similarity measure:
```{r}
cult.m = 1-cult.m
```
Convert the linguistic similarities to a matrix.  This uses `igraph` to make an undirected graph from the long format with `local_alignment` as the edge weights, then output a matrix of adjacencies.
```{r}
grph <- graph.data.frame(ling[,c("l1",'l2','local_alignment')], directed=FALSE)
# add value as a weight attribute
ling.m = get.adjacency(grph, attr="local_alignment", sparse=FALSE)
rownames(ling.m) = l[match(rownames(ling.m),l$iso2),]$Language2
colnames(ling.m) = l[match(colnames(ling.m),l$iso2),]$Language2
```
Load the geographic distances:
```{r}
geoDist = read.csv("../data/GeographicDistances.csv",stringsAsFactors = F)
geoDist.m = as.matrix(geoDist)
# Convert to log distance
geoDist.m = log(geoDist.m)
geoDist.m[is.infinite(geoDist.m)] = 0
rownames(geoDist.m) = colnames(geoDist.m)
```
Match the distance matrices
```{r}
in.analysis = intersect(rownames(ling.m),rownames(cult.m))
in.analysis = intersect(in.analysis, rownames(hist.m))
cult.m2 = cult.m[in.analysis,in.analysis]
ling.m2 = ling.m[in.analysis,in.analysis]
hist.m2 = hist.m[in.analysis,in.analysis]
geo.m2 = geoDist.m[in.analysis,in.analysis]
```
Note that there are only `r length(in.analysis)` languages with data on lingusitic, cultural and historical distance.
```{r}
plot(as.dist(cult.m2),as.dist(ling.m2),
xlab="Cultural similarity",
ylab="Linguistic similarity")
plot(as.dist(cult.m2),as.dist(hist.m2),
xlab="Cultural similarity",
ylab="Historical distance")
plot(as.dist(ling.m2),as.dist(hist.m2),
xlab="Linguistic similarity",
ylab="Historical distance")
```
```{r warning=F,echo=F}
t = read.nexus("../data/trees/bouckaert_et_al2012-d-place_2.NEXUS")
treenames = read.csv("../data/trees/taxa.csv", stringsAsFactors = F)
# These are not necessarily the right glottocode, but they do link the right data
treenames[treenames$taxon=="Albanian_G",]$glottocode = "gheg1238"
treenames[treenames$taxon=="Greek_Mod",]$glottocode = "mode1248"
# convert tip labels to glotto codes
t$tip.label = treenames[match(t$tip.label,treenames$taxon),]$glottocode
t2 = drop.tip(t,t$tip.label[!t$tip.label %in% l[match(in.analysis,l$Language),]$glotto])
t2$tip.label = l[match(t2$tip.label,l$glotto),]$Language
plot(t2)
```
distms = list("Cultrual"= cult.m2,
"Linguistic" = ling.m2,
"Historical" = hist.m2,
"Geographic" = geo.m2)
for(i in 1:3){
for(j in (i+1):4){
var1 = names(distms)[i]
var2 = names(distms)[j]
print(paste("Correlation between",
var1,"and",var2))
stat = ecodist::mantel(as.dist(distms[[i]]) ~
as.dist(distms[[j]]),
nperm = 100000)
print(stat)
if(var1=="Linguistic" && var2=="Historical"){
stat2 = sprintf("r = %s[%s,%s], one-tailed p = %s",
)
cat(stat2,file="../results/stats/tex/MantelSemanticVsHistoricalDistance.tex")
}
}
}
stat
stat[1]
stat$mantelr
sprintf("r = %s[%s,%s], one-tailed p = %s",
stat[1],
stat[5],
stat[6],
stat[2]
)
sprintf("r = %s[%s,%s], one-tailed p = %s",
c(stat[1],
stat[5],
stat[6],
stat[2])
)
stat = round(stat,2)
if(var1=="Linguistic" && var2=="Historical"){
stat2 = sprintf("r = %s[%s,%s], one-tailed p = %s",
stat[1],
stat[5],
stat[6],
stat[2]
)
sprintf("r = %s[%s,%s], one-tailed p = %s",
stat[1],
stat[5],
stat[6],
stat[2]
)
sprintf("r = %s[%s,%s], one-tailed p = %s",
stat[1],
stat[5],
stat[6],
stat[3]
)
stat2 = sprintf("r = %s[%s,%s], one-tailed p = %s",
stat[1],
stat[5],
stat[6],
stat[3]
)
cat(stat2,file="../results/stats/tex/MantelSemanticVsHistoricalDistance.tex")
stat2 = sprintf("$r$ = %s[%s,%s], one-tailed $p$ = %s",
stat[1],
stat[5],
stat[6],
stat[3]
)
cat(stat2,file="../results/stats/tex/MantelSemanticVsHistoricalDistance.tex")
dim(ling.m2)
mainMantel = ecodist::mantel(as.dist(ling.m2)~
as.dist(cult.m2) +
as.dist(hist.m2) +
as.dist(geo.m2),
nperm = 100000)
mainMantel
sprintf("$r$ = %s[%s,%s], one-tailed $p$ = %s",
mainMantel[1],
mainMantel[5],
mainMantel[6],
mainMantel[3]
)
mainMantel = round(mainMantel,2)
sprintf("$r$ = %s[%s,%s], one-tailed $p$ = %s",
mainMantel[1],
mainMantel[5],
mainMantel[6],
mainMantel[2]
)
distms = list("Cultrual"= cult.m2,
"Linguistic" = ling.m2,
"Historical" = hist.m2,
"Geographic" = geo.m2)
for(i in 1:3){
for(j in (i+1):4){
var1 = names(distms)[i]
var2 = names(distms)[j]
print(paste("Correlation between",
var1,"and",var2))
stat = ecodist::mantel(as.dist(distms[[i]]) ~
as.dist(distms[[j]]),
nperm = 100000)
print(stat)
stat = round(stat,2)
stat2 = sprintf("$r$ = %s[%s,%s], one-tailed $p$ = %s",
stat[1],
stat[5],
stat[6],
stat[3])
cat(stat2,file=
paste("../results/stats/tex/Mantel",var1,"Vs",var2,"Distance.tex"))
}
}
distms = list("Cultrual"= cult.m2,
"Linguistic" = ling.m2,
"Historical" = hist.m2,
"Geographic" = geo.m2)
for(i in 1:3){
for(j in (i+1):4){
var1 = names(distms)[i]
var2 = names(distms)[j]
print(paste("Correlation between",
var1,"and",var2))
stat = ecodist::mantel(as.dist(distms[[i]]) ~
as.dist(distms[[j]]),
nperm = 100000)
print(stat)
stat = round(stat,2)
stat2 = sprintf("$r$ = %s[%s,%s], one-tailed $p$ = %s",
stat[1],
stat[5],
stat[6],
stat[3])
cat(stat2,file=
paste0("../results/stats/tex/Mantel",var1,"Vs",var2,"Distance.tex"))
}
}
mainMantel = ecodist::mantel(as.dist(ling.m2)~
as.dist(cult.m2) +
as.dist(hist.m2) +
as.dist(geo.m2),
nperm = 100000)
mainMantel
```
```{r}
mainMantel = round(mainMantel,2)
mainMantel2 = sprintf("$r$ = %s[%s,%s], one-tailed $p$ = %s",
mainMantel[1],
mainMantel[5],
mainMantel[6],
mainMantel[2]
)
cat(mainMantel2,
file="../results/stats/tex/MantelCultrualVsLinguisticDistance_Partial.tex")
ecodist::MRM(as.dist(ling.m2)~
as.dist(cult.m2) +
as.dist(hist.m2) +
as.dist(geo.m2), nperm=10000)
coef(mainMRM)
mainMRM = ecodist::MRM(as.dist(ling.m2)~
as.dist(cult.m2) +
as.dist(hist.m2) +
as.dist(geo.m2), nperm=10000)
mainMRM$coef[1]
mainMRM$coef[2]
summary(mainMRM)
x = summary(mainMRM)
x
mainMRM
mainMRM$coef[2]
mainMRM$coef
mainMRM$coef[2,1]
mainMRM2 = sprintf("$\beta= $%s, $p=$%s",
round(mainMRM$coef[2,1],2),
round(mainMRM$coef[2,2],2))
cat(mainMRM,
file="../results/stats/tex/MRMCultrualVsLinguisticDistance_Partial.tex")
mainMRM2 = sprintf("$\beta= $%s, $p=$%s",
round(mainMRM$coef[2,1],2),
round(mainMRM$coef[2,2],2))
cat(mainMRM2,
file="../results/stats/tex/MRMCultrualVsLinguisticDistance_Partial.tex")
mainMRM2 = sprintf("$\\beta= $%s, $p=$%s",
round(mainMRM$coef[2,1],2),
round(mainMRM$coef[2,2],2))
cat(mainMRM2,
file="../results/stats/tex/MRMCultrualVsLinguisticDistance_Partial.tex")

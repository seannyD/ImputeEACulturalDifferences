t2 = drop.tip(t,t$tip.label[!t$tip.label %in% l[match(in.analysis,l$Language),]$glotto])
t2$tip.label = l[match(t2$tip.label,l$glotto),]$Language
plot(t2)
```
\newpage
## Tests
The results of the test list the following measures:
-  mantelr: Mantel correlation coefficient.
-  pval1: one-tailed p-value (null hypothesis: r <= 0).
-  pval2: one-tailed p-value (null hypothesis: r >= 0).
-  pval3: two-tailed p-value (null hypothesis: r = 0).
-  llim: lower confidence limit for r.
-  ulim: upper confidence limit for r.
```{r}
set.seed(1498)
```
Run tests between each pair of measures.
```{r}
distms = list("Cultrual"= cult.m2,
"Linguistic" = ling.m2,
"Historical" = hist.m2,
"Geographic" = geo.m2)
mantelRes1 = data.frame()
for(i in 1:3){
for(j in (i+1):4){
var1 = names(distms)[i]
var2 = names(distms)[j]
print(paste("Correlation between",
var1,"and",var2))
stat = ecodist::mantel(as.dist(distms[[i]]) ~
as.dist(distms[[j]]),
nperm = 100000)
print(stat)
mantelRes1 = rbind(mantelRes1,
c(var1,var2,stat[1],stat[5],stat[6],
min(c(stat[2],stat[3]))))
stat = round(stat,2)
stat2 = sprintf("$r$ = %s[%s,%s], one-tailed $p$ = %s",
stat[1],
stat[5],
stat[6],
min(c(stat[2],stat[3])))
# TODO: output stats
#cat(stat2,file=
#     paste0("../results/stats/tex/Mantel",var1,"Vs",var2,"Distance_CC.tex"))
}
}
names(mantelRes1) = c("Var1","Var2","r","Lower","Upper","p")
mantelRes1
warnings()
mantelRes1 = rbind(mantelRes1,
c(var1,var2,stat[1],stat[5],stat[6],
min(c(stat[2],stat[3]))), stringsAsFactors=F)
mantelRes1 = data.frame(stringsAsFactors = F)
for(i in 1:3){
for(j in (i+1):4){
var1 = names(distms)[i]
var2 = names(distms)[j]
print(paste("Correlation between",
var1,"and",var2))
stat = ecodist::mantel(as.dist(distms[[i]]) ~
as.dist(distms[[j]]),
nperm = 100000)
print(stat)
mantelRes1 = rbind(mantelRes1,
c(var1,var2,stat[1],stat[5],stat[6],
min(c(stat[2],stat[3]))))
stat = round(stat,2)
stat2 = sprintf("$r$ = %s[%s,%s], one-tailed $p$ = %s",
stat[1],
stat[5],
stat[6],
min(c(stat[2],stat[3])))
# TODO: output stats
#cat(stat2,file=
#     paste0("../results/stats/tex/Mantel",var1,"Vs",var2,"Distance_CC.tex"))
}
}
mantelRes1 = data.frame(
Var1 = NA, Var2 = NA, r = NA,
llim = NA, ulim = NA, p = NA,
stringsAsFactors = F)
for(i in 1:3){
for(j in (i+1):4){
var1 = names(distms)[i]
var2 = names(distms)[j]
print(paste("Correlation between",
var1,"and",var2))
stat = ecodist::mantel(as.dist(distms[[i]]) ~
as.dist(distms[[j]]),
nperm = 100000)
print(stat)
mantelRes1 = rbind(mantelRes1,
c(var1,var2,stat[1],stat[5],stat[6],
min(c(stat[2],stat[3]))))
stat = round(stat,2)
stat2 = sprintf("$r$ = %s[%s,%s], one-tailed $p$ = %s",
stat[1],
stat[5],
stat[6],
min(c(stat[2],stat[3])))
# TODO: output stats
#cat(stat2,file=
#     paste0("../results/stats/tex/Mantel",var1,"Vs",var2,"Distance_CC.tex"))
}
}
mantelRes1
mantelRes1= [2:nrow(mantelRes1),]
mantelRes1= mantelRes1[2:nrow(mantelRes1),]
mantelRes1[,3:6] = signif(mantelRes1[,3:6],3)
mantelRes1[,3:6] = apply(mantelRes1[,3:6],2,function(X){
signif(as.numeric(X),3)
})
mantelRes1
xtable(mantelRes1)
mainMantel
mainMantel = ecodist::mantel(as.dist(ling.m2)~
as.dist(cult.m2) +
as.dist(hist.m2) +
as.dist(geo.m2),
nperm = 100000)
mainMantel
mainMantel
mantelRes1
min(mainMantel[2:3])
rbind(mantelRes1,
c("Linguistic","Cultural (controlling for historical and geographical)",
mainMantel[1],mainMantel[5],mainMantel[6],
min(mainMantel[2:3])))
mainMantel = signif(mainMantel,3)
mantelRes1 = rbind(mantelRes1,
c("Linguistic","Cultural (controlling for historical and geographical)",
mainMantel[1],mainMantel[5],mainMantel[6],
min(mainMantel[2:3])))
mantelRes1
xtable(mantelRes1,
caption =  paste0(
"Mantel tests (",
datasetLabel,"). ** = partial Mantel test, controlling for historical and geographical distance.")
xtable(mantelRes1,
caption =  paste0(
"Mantel tests (",
datasetLabel,"). ** = partial Mantel test, controlling for historical and geographical distance."))
mainMRM = ecodist::MRM(as.dist(ling.m2)~
as.dist(cult.m2) +
as.dist(hist.m2) +
as.dist(geo.m2), nperm=10000)
mainMRM
set.seed(289)
MRM.fam = ecodist::MRM(as.dist(ling.m) ~
as.dist(cult.m) +
as.dist(family.matrix) +
as.dist(geoDist.m1)  +
as.dist(cc.m),nperm = 10000)
MRM.asjp = ecodist::MRM(as.dist(ling.m2) ~
as.dist(cult.m2) +
as.dist(asjp.m) +
as.dist(geoDist.m2) +
as.dist(cc.m2),nperm = 10000)
---
title: "Cultural distances: Common crawl data"
output:
pdf_document:
toc: true
---
```{r echo=F, eval=F}
setwd("~/Documents/Bristol/word2vec/word2vec_DPLACE/analysis/")
```
# Introduction
This file replicates the tests for the main wikipedia data on the common crawl data.
# Load libraries
```{r warning=F, message=F}
library(ape)
library(ecodist)
library(lme4)
library(sjPlot)
library(ggplot2)
library(igraph)
library(lattice)
library(xtable)
```
Parameters (using data from Northuralex and common crawl, k=100, unfiltered):
```{r}
datasetName = "cc"
datasetLabel = "Common Crawl"
lingDistancesFile = "../data/FAIR/nel-k100-cc-alignments-by-language-pair.csv"
lingDistancesFileNK = "../data/FAIR/nel-k100-cc-alignments-by-language-pair-without-kinsip.csv"
lingDistancesByDomainFile = "../results/EA_distances/nel-k100-cc_with_ling.csv"
# (generated by ../processing/combineCultAndLingDistances.R)
```
\newpage
# All domains
## Load data
Read the cultural distances:
```{r}
cult = read.csv("../results/EA_distances/CulturalDistances_Long.csv", stringsAsFactors = F)
names(cult) = c("l1","l2","cult.dist")
```
Add language family:
```{r}
l = read.csv("../data/FAIR_langauges_glotto_xdid.csv", stringsAsFactors = F)
g = read.csv("../data/glottolog-languoid.csv/languoid.csv", stringsAsFactors = F)
l$family = g[match(l$glotto,g$id),]$family_pk
l$family = g[match(l$family,g$pk),]$name
```
Read the semantic distances
```{r}
ling = read.csv(lingDistancesFile, stringsAsFactors = F)
```
There are very few possible comparisons for Slovenian and Northern Sami, so we'll remove these:
```{r}
ling = ling[!(ling$l1=="se" | ling$l2 == "se"),]
ling = ling[!(ling$l1=="sl" | ling$l2 == "sl"),]
```
Combine the lingusitic and cultural distances. Note that we flip the cultural measure from a distance measure to a similarity measure.
```{r}
cult$l1.iso2 = l[match(cult$l1,l$Language2),]$iso2
cult$l2.iso2 = l[match(cult$l2,l$Language2),]$iso2
fairisos = unique(c(ling$l1,ling$l2))
cultisos = unique(c(cult$l1.iso2, cult$l2.iso2))
cult = cult[(cult$l1.iso2 %in% fairisos) & (cult$l2.iso2 %in% fairisos),]
ling = ling[(ling$l1 %in% cultisos) & (ling$l2 %in% cultisos),]
matches = sapply(1:nrow(ling), function(i){
which(cult$l1.iso2==ling$l1[i] & cult$l2.iso2==ling$l2[i])
})
ling$cult.dist = cult[matches,]$cult.dist
# Flip
ling$cult.dist = 1 - ling$cult.dist
# Scale
ling$cult.dist.center = scale(ling$cult.dist)
cdc.s = attr(ling$cult.dist.center,"scaled:scale")
cdc.c = attr(ling$cult.dist.center,"scaled:center")
ling$cult.dist.center = as.numeric(ling$cult.dist.center)
ling$comparison_count.center =
scale(ling$comparison_count)
ling$family1 = l[match(ling$l1, l$iso2),]$family
ling$family2 = l[match(ling$l2, l$iso2),]$family
l[l$Language=="Arabic",]$autotyp.area= "Greater Mesopotamia"
l[l$Language=="Persian",]$autotyp.area= "Greater Mesopotamia"
ling$area1 = l[match(ling$l1, l$iso2),]$autotyp.area
ling$area2 = l[match(ling$l2, l$iso2),]$autotyp.area
fgroup = cbind(ling$family1,ling$family2)
fgroup = apply(fgroup,1,sort)
ling$family.group = apply(fgroup,2,paste,collapse=":")
agroup = cbind(ling$area1,ling$area2)
agroup = apply(agroup,1,sort)
ling$area.group = apply(agroup,2,paste,collapse=":")
ling$rho.center = scale(ling$local_alignment)
```
Each observation is now assocaited with a language family pair:
```{r}
head(ling[,c("l1","l2","local_alignment",'family.group')])
```
And the same is true for area:
```{r}
tail(ling[,c("l1","l2","local_alignment",'area.group')])
```
Number of observations:
```{r}
# Number of datapoints:
nrow(ling)
# Number of unique languages:
length(unique(unlist(ling[,c("l1","l2")])))
# Number of unique langauge families:
uniqueFamilies = unique(unlist(ling[,c("family1","family2")]))
length(uniqueFamilies)
# Number of unique areas:
uniqueAreas = unique(unlist(ling[,c("area1","area2")]))
length(uniqueAreas)
```
Cross-over between language famlies and areas:
```{r}
tx = data.frame(lang= c(ling$l1,ling$l2),
fam = c(ling$family1,ling$family2),
area= c(ling$area1,ling$area2))
tx = tx[!duplicated(tx),]
table(tx$fam,tx$area)
```
\newpage
## LMER models
Mixed effects model, predicting Linguistic similaritys from cultural similarity, with random intercept for family and area and random slope for cultural similarity for family and area.
We start with a null model with random intercepts for family and area, and random slopes for cultural similarity by both. We add a fixed effect of the number of comparisons made for each datapoint (number of concepts that were available to compare). Then we add a fixed effect of cultural similarity
```{r}
m0 = lmer(
rho.center ~ 1 +
(1 + cult.dist.center | family.group) +
(1 + cult.dist.center | area.group),
data = ling
)
m0.5 = lmer(
rho.center ~ 1 +
comparison_count.center +
(1 + cult.dist.center | family.group) +
(1 + cult.dist.center | area.group),
data = ling
)
m1 = lmer(
rho.center ~ 1 +
comparison_count.center +
cult.dist.center +
(1 + cult.dist.center | family.group) +
(1 + cult.dist.center | area.group),
data = ling
)
an1 = anova(m0,m0.5,m1)
an1
```
Cultural similarity is significantly correlated with Linguistic similarity.  Here are the model estimates:
```{r}
summary(m1)
```
```{r echo=F,message=F,warning=F}
stat0 = sprintf("$\\beta$= %s, $\\chi^2$(%s)= %s, $p$=%s",
signif(fixef(m1)[3],3),
an1$`Chi Df`[3],
round(an1$Chisq[3],2),
format(signif(an1$`Pr(>Chisq)`[3],2),scientific=F))
cat(stat0,file="../results/stats/tex/MEM_CulturalVsLinguistic_CC.tex")
```
Plot the estimates, rescaling the variables back to the original units:
```{r}
trans = function(X){
X * attr(ling$rho.center,"scaled:scale") +
attr(ling$rho.center,"scaled:center")
}
gx = plot_model(m1,'pred',terms='cult.dist.center')
gx$data$predicted = trans(gx$data$predicted)
gx$data$conf.low = trans(gx$data$conf.low)
gx$data$conf.high = trans(gx$data$conf.high)
gx$data$x = gx$data$x *
cdc.s +cdc.c
gx = gx + #coord_cartesian(ylim=c(0,0.5),
#                xlim=c(0.15,0.85)) +
xlab("Cultural similarity") +
ylab("Semantic alignment") +
ggtitle("") +
geom_point(data=ling,aes(x=cult.dist,y=local_alignment))
gx
pdf(paste0("../results/stats/",datasetName,"/CulturalDistance_Rho_Graph.pdf"),
height=2.5, width=2.5)
gx
dev.off()
```
Plot the random effects:
```{r}
plot_model(m1,'re', sort.est = "cult.dist.center")
```
##  MRM
Use multiple regression on distance matrices to do the same test as above.  The code below loads the data into a matrix format:
```{r}
# Use graph method to make distance matrix
grph <- graph.data.frame(ling[,c("l1",'l2','local_alignment')], directed=FALSE)
# add value as a weight attribute
ling.m = get.adjacency(grph, attr="local_alignment", sparse=FALSE)
rownames(ling.m) = l[match(rownames(ling.m),l$iso2),]$Language2
colnames(ling.m) = l[match(colnames(ling.m),l$iso2),]$Language2
# Same for comparison_count.center
grph <- graph.data.frame(ling[,c("l1",'l2','comparison_count')], directed=FALSE)
# add value as a weight attribute
cc.m = get.adjacency(grph, attr="comparison_count", sparse=FALSE)
rownames(cc.m) = l[match(rownames(cc.m),l$iso2),]$Language2
colnames(cc.m) = l[match(colnames(cc.m),l$iso2),]$Language2
cult.m = read.csv("../results/EA_distances/CulturalDistances.csv", stringsAsFactors = F)
rownames(cult.m) = cult.m[,1]
cult.m = cult.m[,2:ncol(cult.m)]
cult.m = as.matrix(cult.m)
# Flip cultural value to distance
cult.m = 1-cult.m
mx = match(rownames(ling.m),rownames(cult.m))
cult.m = cult.m[mx,mx]
colnames(cult.m) = rownames(cult.m)
# Same/different matrix for language family
family.matrix = l[match(rownames(ling.m),l$Language),]$family
family.matrix = outer(family.matrix,family.matrix,"!=") *1
# Load ASJP distances for second test
asjp = readRDS("../data/ASJP/asjp17-dists_FAIR.RData")
ling.m.glotto = l[match(rownames(cult.m),l$Language2),]$glotto
ling.m.glotto = ling.m.glotto[ling.m.glotto %in% rownames(asjp)]
asjp.m = asjp[ling.m.glotto,ling.m.glotto]
asjp.lang.names = l[match(rownames(asjp.m),l$glotto),]$Language2
# Matrices for second analysis with asjp
ling.m2 = ling.m[asjp.lang.names,asjp.lang.names]
cult.m2 = cult.m[asjp.lang.names,asjp.lang.names]
cc.m2 =  cc.m[asjp.lang.names,asjp.lang.names]
# Load the geographic distances:
geoDist = read.csv("../data/GeographicDistances.csv",stringsAsFactors = F)
geoDist.m = as.matrix(geoDist)
geoDist.m = geoDist.m[!is.na(geoDist.m[,1]),!is.na(geoDist.m[1,])]
# Convert to log distance in thousand km
geoDist.m = log10(geoDist.m/1000)
geoDist.m[is.infinite(geoDist.m)] = 0
colnames(geoDist.m) = gsub("\\."," ",colnames(geoDist.m))
rownames(geoDist.m) = colnames(geoDist.m)
geoDist.m1 = geoDist.m[rownames(ling.m),rownames(ling.m)]
geoDist.m2 = geoDist.m[rownames(ling.m2),rownames(ling.m2)]
# center and scale values
ling.m =  matrix(scale(as.vector(ling.m)),nrow=nrow(ling.m))
cc.m =  matrix(scale(as.vector(cc.m)),nrow=nrow(cc.m))
cult.m = matrix(scale(as.vector(cult.m)),nrow=nrow(cult.m))
geoDist.m1 = matrix(scale(as.vector(geoDist.m1)),nrow=nrow(geoDist.m1))
asjp.m = matrix(scale(as.vector(asjp.m)),nrow=nrow(asjp.m))
ling.m2 = matrix(scale(as.vector(ling.m2)),nrow=nrow(ling.m2))
cc.m2 =  matrix(scale(as.vector(cc.m2)),nrow=nrow(cc.m2))
cult.m2 = matrix(scale(as.vector(cult.m2)),nrow=nrow(cult.m2))
geoDist.m2 = matrix(scale(as.vector(geoDist.m2)),nrow=nrow(geoDist.m2))
```
\newpage
Run the MRM model, predicting semantic alignment by cultural distance, controlling for family distance, geographic ditance, and the comparison count (number of observations). Here, the family distance between two languages is just whether they are part of the same family.  Note that this does not take into account particular values for particular families, nor the random slopes within families.
```{r}
set.seed(289)
MRM.fam = ecodist::MRM(as.dist(ling.m) ~
as.dist(cult.m) +
as.dist(family.matrix) +
as.dist(geoDist.m1)  +
as.dist(cc.m),nperm = 10000)
MRM.asjp = ecodist::MRM(as.dist(ling.m2) ~
as.dist(cult.m2) +
as.dist(asjp.m) +
as.dist(geoDist.m2) +
as.dist(cc.m2),nperm = 10000)
rownames(MRM.fam$coef) = c("Intercept","Cultural distance","Language family",
"Geographic distance","Comparison count")
colnames(MRM.fam$coef) = c("Estimate","p-value")
statMRM.fam = xtable(MRM.fam$coef, digits = 3,display=c("s",'f',"fg"),
caption = paste0(
"MRM analysis predicting semantic alignment (",
datasetLabel,"), with family control. $R^2$=",
signif(MRM.fam$r.squared[1],3)))
cat(statMRM.fam, paste0(stat0,file="../results/stats/tex/MRM_family_CC.tex"))
statMRM.fam
paste0(statMRM.fam,collapse="\n")
print(statMRM.fam)
print(statMRM.fam,"latex")
cat(print(statMRM.fam,"latex"), paste0(stat0,file="../results/stats/tex/MRM_family_CC.tex"))
?print.xtable
print(mantelRes1Text,
file="../results/stats/tex/Mantel_CC.tex")
stat0
statMRM.fam
print(statMRM.fam,"latex",
file=paste0(stat0,file="../results/stats/tex/MRM_family_CC.tex")
print(statMRM.fam,"latex",
file=paste0(stat0,file="../results/stats/tex/MRM_family_CC.tex"))
statMRM.fam
print(statMRM.fam,"latex",
file="../results/stats/tex/MRM_family_CC.tex")
ecodist::MRM(as.dist(ling.m) ~
as.dist(cult.m) +
as.dist(family.matrix) +
as.dist(geoDist.m1)  +
as.dist(cc.m),nperm = 10000)
t = read.nexus("../data/trees/bouckaert_et_al2012-d-place_2.NEXUS")
treenames = read.csv("../data/trees/taxa.csv", stringsAsFactors = F)
# These are not necessarily the right glottocode, but they do link the right data
treenames[treenames$taxon=="Albanian_G",]$glottocode = "gheg1238"
treenames[treenames$taxon=="Greek_Mod",]$glottocode = "mode1248"
# convert tip labels to glotto codes
t$tip.label = treenames[match(t$tip.label,treenames$taxon),]$glottocode
t2 = drop.tip(t,t$tip.label[!t$tip.label %in% l[match(in.analysis,l$Language),]$glotto])
t2$tip.label = l[match(t2$tip.label,l$glotto),]$Language
plot(t2)
t2 = drop.tip(t,t$tip.label[duplicated(t$tip.label)])
plot(t2)
t = read.nexus("../data/trees/bouckaert_et_al2012-d-place_2.NEXUS")
treenames = read.csv("../data/trees/taxa.csv", stringsAsFactors = F)
# These are not necessarily the right glottocode, but they do link the right data
treenames[treenames$taxon=="Albanian_G",]$glottocode = "gheg1238"
treenames[treenames$taxon=="Greek_Mod",]$glottocode = "mode1248"
# convert tip labels to glotto codes
t$tip.label = treenames[match(t$tip.label,treenames$taxon),]$glottocode
t2 = drop.tip(t,t$tip.label[!t$tip.label %in% l[match(in.analysis,l$Language),]$glotto])
t$tip.label
t$tip.label[duplicated(t$tu)]
t$tip.label[duplicated(t$tip.label)]
t2 = drop.tip(t2,t$tip.label[duplicated(t$tip.label)])
t2$tip.label = l[match(t2$tip.label,l$glotto),]$Language
plot(t2)
?drop.tip
t = read.nexus("../data/trees/bouckaert_et_al2012-d-place_2.NEXUS")
treenames = read.csv("../data/trees/taxa.csv", stringsAsFactors = F)
# These are not necessarily the right glottocode, but they do link the right data
treenames[treenames$taxon=="Albanian_G",]$glottocode = "gheg1238"
treenames[treenames$taxon=="Greek_Mod",]$glottocode = "mode1248"
# convert tip labels to glotto codes
t$tip.label = treenames[match(t$tip.label,treenames$taxon),]$glottocode
t2 = drop.tip(t,t$tip.label[!t$tip.label %in% l[match(in.analysis,l$Language),]$glotto])
t2 = drop.tip(t2,which(duplicated(t$tip.label)))
t = read.nexus("../data/trees/bouckaert_et_al2012-d-place_2.NEXUS")
treenames = read.csv("../data/trees/taxa.csv", stringsAsFactors = F)
# These are not necessarily the right glottocode, but they do link the right data
treenames[treenames$taxon=="Albanian_G",]$glottocode = "gheg1238"
treenames[treenames$taxon=="Greek_Mod",]$glottocode = "mode1248"
# convert tip labels to glotto codes
t$tip.label = treenames[match(t$tip.label,treenames$taxon),]$glottocode
t2 = drop.tip(t,t$tip.label[!t$tip.label %in% l[match(in.analysis,l$Language),]$glotto])
t2$tip.label
which(duplicated(t$tip.label)
)
t2 = drop.tip(t2,which(duplicated(t2$tip.label)))
plot(t2)
t = read.nexus("../data/trees/bouckaert_et_al2012-d-place_2.NEXUS")
treenames = read.csv("../data/trees/taxa.csv", stringsAsFactors = F)
# These are not necessarily the right glottocode, but they do link the right data
treenames[treenames$taxon=="Albanian_G",]$glottocode = "gheg1238"
treenames[treenames$taxon=="Greek_Mod",]$glottocode = "mode1248"
# convert tip labels to glotto codes
t$tip.label = treenames[match(t$tip.label,treenames$taxon),]$glottocode
t2 = drop.tip(t,t$tip.label[!t$tip.label %in% l[match(in.analysis,l$Language),]$glotto])
t2 = drop.tip(t2,which(duplicated(t2$tip.label)))
t2$tip.label = l[match(t2$tip.label,l$glotto),]$Language
plot(t2)
plot(t2)

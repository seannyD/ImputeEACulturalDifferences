in.analysis = intersect(rownames(ling.m),rownames(cult.m))
in.analysis = intersect(in.analysis, rownames(hist.m))
cult.m2 = cult.m[in.analysis,in.analysis]
ling.m2 = ling.m[in.analysis,in.analysis]
hist.m2 = hist.m[in.analysis,in.analysis]
rownames(cult.m2)
cult.m2 = cult.m2[-1,-1]
ling.m2 = ling.m2[-1,-1]
ecodist::mantel(as.dist(ling.m2)~
as.dist(cult.m2) +
as.dist(hist.m2),
nperm = 100000)
dim(ling.m2)
hist.m2 = hist.m2[-1,-1]
ecodist::mantel(as.dist(ling.m2)~
as.dist(cult.m2) +
as.dist(hist.m2),
nperm = 100000)
l[l$Language2=="Ukrainian",]
l[l$Language2=="Ukranian",]
rownames(ling.m2)
hist = read.csv("../data/trees/IndoEuropean_historical_distances.csv", stringsAsFactors = F)
hist = hist[!duplicated(hist[,1]),!duplicated(hist[,1])]
rownames(hist) = hist[,1]
hist = hist[,2:ncol(hist)]
hist.m = as.matrix(hist)
colnames(hist.m) = rownames(hist.m)
hist.m = hist.m/max(hist.m)
```
Read the cultural distances as a matrix:
```{r}
cult.m = read.csv("../results/EA_distances/CulturalDistances.csv", stringsAsFactors = F)
rownames(cult.m) = cult.m[,1]
cult.m = cult.m[,2:ncol(cult.m)]
```
Convert the linguistic similarities to a matrix.  This uses `igraph` to make an undirected graph from the long format with `rho` as the edge weights, then output a matrix of adjacencies.
```{r}
grph <- graph.data.frame(ling[,c("l1",'l2','rho')], directed=FALSE)
# add value as a weight attribute
ling.m = get.adjacency(grph, attr="rho", sparse=FALSE)
rownames(ling.m) = l[match(rownames(ling.m),l$iso2),]$Language2
colnames(ling.m) = l[match(colnames(ling.m),l$iso2),]$Language2
```
Match the distance matrices
```{r}
in.analysis = intersect(rownames(ling.m),rownames(cult.m))
in.analysis = intersect(in.analysis, rownames(hist.m))
cult.m2 = cult.m[in.analysis,in.analysis]
ling.m2 = ling.m[in.analysis,in.analysis]
hist.m2 = hist.m[in.analysis,in.analysis]
rownames(ling.m2)
ling.m2 =ling.m2[-1,-1]
rownames(ling.m2)
plot(as.dist(cult.m),as.dist(ling.m))
plot(as.dist(cult.m2),as.dist(ling.m2))
cult.m2 = cult.m[in.analysis,in.analysis]
ling.m2 = ling.m[in.analysis,in.analysis]
hist.m2 = hist.m[in.analysis,in.analysis]
plot(as.dist(cult.m2),as.dist(ling.m2))
plot(as.dist(cult.m2),as.dist(ling.m2),
xlab="Cultural dsitance",
ylab="Linguistic similarity")
plot(as.dist(cult.m2),as.dist(ling.m2),
xlab="Cultural dsitance",
ylab="Historical distance")
plot(as.dist(cult.m2),as.dist(hist.m2),
xlab="Cultural dsitance",
ylab="Historical distance")
plot(as.dist(ling.m2),as.dist(hist.m2),
xlab="Linguistic similarity",
ylab="Historical distance")
rownames(ling.m2)
ling.m2 = ling.m2[-17,-17]
cult.m2 = cult.m2[-17,-17]
hist.m2 = hist.m2[-17,-17]
ecodist::mantel(as.dist(cult.m2) ~
as.dist(ling.m2),
nperm = 100000)
ecodist::mantel(as.dist(ling.m2)~
as.dist(cult.m2) +
as.dist(hist.m2),
nperm = 100000)
ling$family1
table(ling$family1)
ling[!duplicated(ling$l1),]$family1
table(ling[!duplicated(ling$l1),]$family1)
ling[!duplicated(ling$l1),]$language1
ling[!duplicated(ling$l1),]$lang1
names(ling)
ling[!duplicated(ling$l1),]$l1
ling
ling$rho
ling$cult.dist
ling$l1
ling[!duplicated(ling$l1),]$l1
head(hist)
rownames(cult.m)
rownames(cult.m2)
ling[!duplicated(ling$l1),]$l1
names(l)
l[match(ling[!duplicated(ling$l1),]$l1,l$iso2),]$Language2
rownames(cult.m2)
ddata = l[match(ling[!duplicated(ling$l1),]$l1,l$iso2),]$Language2
ddata %in% rownames(cult.m2)
ddata[!ddata %in% rownames(cult.m2)]
# Get historical distances between langauges from phylogentic trees, obtained from D-Place
# Then match up the taxa names to FAIR langauge names
setwd("~/Documents/Bristol/word2vec/word2vec_DPLACE/analysis/")
library(ape)
library(caper)
library(phylobase)
# fair language data
f = read.csv("../data/FAIR_langauges_glotto_xdid.csv", stringsAsFactors = F)
# Indo-European
t = read.nexus("../data/trees/bouckaert_et_al2012-d-place_2.NEXUS")
treenames = read.csv("../data/trees/taxa.csv", stringsAsFactors = F)
head(treenames)
head(g)
head(f)
f$Language=="Albanian"
f[f$Language=="Albanian",]
treenames
names(treenames)
head(t)
head(t$tip.label)
treenames[treenames$taxon=="Albanian_G",]
t$tip.label
head(f)
t$tip.label
# Get historical distances between langauges from phylogentic trees, obtained from D-Place
# Then match up the taxa names to FAIR langauge names
setwd("~/Documents/Bristol/word2vec/word2vec_DPLACE/analysis/")
library(ape)
library(caper)
library(phylobase)
# fair language data
f = read.csv("../data/FAIR_langauges_glotto_xdid.csv", stringsAsFactors = F)
# Indo-European
t = read.nexus("../data/trees/bouckaert_et_al2012-d-place_2.NEXUS")
treenames = read.csv("../data/trees/taxa.csv", stringsAsFactors = F)
# convert tip labels to glotto codes
t$tip.label = treenames[match(t$tip.label,treenames$taxon),]$glottocode
t$tip.label
# Get historical distances between langauges from phylogentic trees, obtained from D-Place
# Then match up the taxa names to FAIR langauge names
setwd("~/Documents/Bristol/word2vec/word2vec_DPLACE/analysis/")
library(ape)
library(caper)
library(phylobase)
# fair language data
f = read.csv("../data/FAIR_langauges_glotto_xdid.csv", stringsAsFactors = F)
# Indo-European
t = read.nexus("../data/trees/bouckaert_et_al2012-d-place_2.NEXUS")
treenames = read.csv("../data/trees/taxa.csv", stringsAsFactors = F)
t$tip.label
t$tip.label = treenames[match(t$tip.label,treenames$taxon),]$glottocode
t$tip.label
ddata[!ddata %in% rownames(cult.m2)]
f[f$Language=="Greek",]
table(f[f$in.final.analysis,]$family)
# Get historical distances between langauges from phylogentic trees, obtained from D-Place
# Then match up the taxa names to FAIR langauge names
setwd("~/Documents/Bristol/word2vec/word2vec_DPLACE/analysis/")
library(ape)
library(caper)
library(phylobase)
# fair language data
f = read.csv("../data/FAIR_langauges_glotto_xdid.csv", stringsAsFactors = F)
# Indo-European
t = read.nexus("../data/trees/bouckaert_et_al2012-d-place_2.NEXUS")
treenames = read.csv("../data/trees/taxa.csv", stringsAsFactors = F)
# These are not necessarily the right glottocode, but they do link the right data
treenames[treenames$taxon=="Albanian_G",]$glottocode = "alba1267"
treenames[treenames$taxon=="Greek_Mod",]$glottocode = "gree1276"
# convert tip labels to glotto codes
t$tip.label = treenames[match(t$tip.label,treenames$taxon),]$glottocode
f[f$xd.id %in% t$tip.label,]
keepTip = f[f$glotto %in% t$tip.label,]$glotto
t = drop.tip(t,t$tip.label[!t$tip.label %in% keepTip])
t$tip.label = f[match(t$tip.label,f$glotto),]$Language2
write.tree(t, "../data/trees/FAIR_tree_IndoEuropean.nwk")
t.dist = cophenetic(t)
write.csv(t.dist, file="../data/trees/IndoEuropean_historical_distances.csv", row.names = T)
t
head(t.dist)
dim(t.dist)
dim(ling.m)
dim(ling.m2)
hist = read.csv("../data/trees/IndoEuropean_historical_distances.csv", stringsAsFactors = F)
hist = hist[!duplicated(hist[,1]),!duplicated(hist[,1])]
rownames(hist) = hist[,1]
hist = hist[,2:ncol(hist)]
hist.m = as.matrix(hist)
colnames(hist.m) = rownames(hist.m)
hist.m = hist.m/max(hist.m)
cult.m = read.csv("../results/EA_distances/CulturalDistances.csv", stringsAsFactors = F)
rownames(cult.m) = cult.m[,1]
cult.m = cult.m[,2:ncol(cult.m)]
grph <- graph.data.frame(ling[,c("l1",'l2','rho')], directed=FALSE)
# add value as a weight attribute
ling.m = get.adjacency(grph, attr="rho", sparse=FALSE)
rownames(ling.m) = l[match(rownames(ling.m),l$iso2),]$Language2
colnames(ling.m) = l[match(colnames(ling.m),l$iso2),]$Language2
```
in.analysis = intersect(rownames(ling.m),rownames(cult.m))
in.analysis = intersect(in.analysis, rownames(hist.m))
cult.m2 = cult.m[in.analysis,in.analysis]
ling.m2 = ling.m[in.analysis,in.analysis]
hist.m2 = hist.m[in.analysis,in.analysis]
length(in.analysis)
plot(as.dist(cult.m2),as.dist(ling.m2),
xlab="Cultural distance",
ylab="Linguistic similarity")
plot(as.dist(cult.m2),as.dist(hist.m2),
xlab="Cultural distance",
ylab="Historical distance")
plot(as.dist(ling.m2),as.dist(hist.m2),
xlab="Linguistic similarity",
ylab="Historical distance")
set.seed(1498)
ecodist::mantel(as.dist(cult.m2) ~
as.dist(ling.m2),
nperm = 100000)
ecodist::mantel(as.dist(ling.m2)~
as.dist(cult.m2) +
as.dist(hist.m2),
nperm = 100000)
dim(ling)
ling$l1=="Greek"
sum(ling$l1=="Greek")
cult = read.csv("../results/EA_distances/CulturalDistances_Long.csv", stringsAsFactors = F)
head(cult)
names(cult) = c("l1","l2","cult.dist")
unique(cult$l1)
sort(unique(cult$l1))
ling = read.csv("../data/FAIR/semantic_distances_FAIR_extended.csv", stringsAsFactors = F)
ling$l1
unique(ling$l1)
sort(unique(ling$l1))
---
title: "Cultural distances: controlling for history"
output: pdf_document
---
```{r echo=F, eval=F}
setwd("~/Documents/Bristol/word2vec/word2vec_DPLACE/analysis/")
```
# Introduction
We compare cultural distances between socieites with linguistic similarities between societies, controlling for shared history in two ways.
The first test uses mixed effects modelling.  The pairing of the langauge family of each language (according to Glottolog) is used as a random effect.  That means that the model can capture the likelihood that two languages from the Indo-European langauge family will be more similar to each other than two languages from different langauge families.  The same is done with geographic area according to Autotyp.
The second test controls for history using distances from a phylogenetic tree.  The tree comes from Bouckaert et al. (2012).  Patristic distances between languages are used as a measure of historical distance between societies in a Mantel test.  Note that the Mantel test assumes a strict distance metric, which is not necessarily the case with this data, but there are few other ways to deal with continuous pairwise distances.
# Load libraries
```{r warning=F, message=F}
library(ape)
library(ecodist)
library(lme4)
library(sjPlot)
library(ggplot2)
library(igraph)
library(lattice)
```
# All domains
## Load data
Read the cultural distances:
```{r}
cult = read.csv("../results/EA_distances/CulturalDistances_Long.csv", stringsAsFactors = F)
names(cult) = c("l1","l2","cult.dist")
cultLangs = unique(c(cult$Var1,cult$Var2))
```
Add language family:
```{r}
l = read.csv("../data/FAIR_langauges_glotto_xdid.csv", stringsAsFactors = F)
g = read.csv("../data/glottolog-languoid.csv/languoid.csv", stringsAsFactors = F)
l$family = g[match(l$glotto,g$id),]$family_pk
l$family = g[match(l$family,g$pk),]$name
```
Read the semantic distances
```{r}
ling = read.csv("../data/FAIR/semantic_distances_FAIR_extended.csv", stringsAsFactors = F)
```
Combine the lingusitic and cultural distances
```{r}
cult$l1.iso2 = l[match(cult$l1,l$Language2),]$iso2
cult$l2.iso2 = l[match(cult$l2,l$Language2),]$iso2
fairisos = unique(c(ling$l1,ling$l2))
cultisos = unique(c(cult$l1.iso2, cult$l2.iso2))
cult = cult[(cult$l1.iso2 %in% fairisos) & (cult$l2.iso2 %in% fairisos),]
ling = ling[(ling$l1 %in% cultisos) & (ling$l2 %in% cultisos),]
cult[cult]
---
title: "Cultural distances: controlling for history"
output: pdf_document
---
```{r echo=F, eval=F}
setwd("~/Documents/Bristol/word2vec/word2vec_DPLACE/analysis/")
```
# Introduction
We compare cultural distances between socieites with linguistic similarities between societies, controlling for shared history in two ways.
The first test uses mixed effects modelling.  The pairing of the langauge family of each language (according to Glottolog) is used as a random effect.  That means that the model can capture the likelihood that two languages from the Indo-European langauge family will be more similar to each other than two languages from different langauge families.  The same is done with geographic area according to Autotyp.
The second test controls for history using distances from a phylogenetic tree.  The tree comes from Bouckaert et al. (2012).  Patristic distances between languages are used as a measure of historical distance between societies in a Mantel test.  Note that the Mantel test assumes a strict distance metric, which is not necessarily the case with this data, but there are few other ways to deal with continuous pairwise distances.
# Load libraries
```{r warning=F, message=F}
library(ape)
library(ecodist)
library(lme4)
library(sjPlot)
library(ggplot2)
library(igraph)
library(lattice)
```
# All domains
## Load data
Read the cultural distances:
```{r}
cult = read.csv("../results/EA_distances/CulturalDistances_Long.csv", stringsAsFactors = F)
names(cult) = c("l1","l2","cult.dist")
cultLangs = unique(c(cult$Var1,cult$Var2))
```
Add language family:
```{r}
l = read.csv("../data/FAIR_langauges_glotto_xdid.csv", stringsAsFactors = F)
g = read.csv("../data/glottolog-languoid.csv/languoid.csv", stringsAsFactors = F)
l$family = g[match(l$glotto,g$id),]$family_pk
l$family = g[match(l$family,g$pk),]$name
```
Read the semantic distances
```{r}
ling = read.csv("../data/FAIR/semantic_distances_FAIR_extended.csv", stringsAsFactors = F)
```
Combine the lingusitic and cultural distances
```{r}
cult$l1.iso2 = l[match(cult$l1,l$Language2),]$iso2
cult$l2.iso2 = l[match(cult$l2,l$Language2),]$iso2
fairisos = unique(c(ling$l1,ling$l2))
cultisos = unique(c(cult$l1.iso2, cult$l2.iso2))
cult[cult$l1=="Greek",]
l[l$Language2=="Greek",]
fairisos
sort(cultisos)
fairisos = unique(c(ling$l1,ling$l2))
cultisos = unique(c(cult$l1.iso2, cult$l2.iso2))
cult = cult[(cult$l1.iso2 %in% fairisos) & (cult$l2.iso2 %in% fairisos),]
ling = ling[(ling$l1 %in% cultisos) & (ling$l2 %in% cultisos),]
cult[cult$l1=='el',]
cult[cult$l1=="Greek",]
matches = sapply(1:nrow(ling), function(i){
which(cult$l1.iso2==ling$l1[i] & cult$l2.iso2==ling$l2[i])
})
ling$cult.dist = cult[matches,]$cult.dist
ling$cult.dist.center = scale(ling$cult.dist)
cdc.s = attr(ling$cult.dist.center,"scaled:scale")
cdc.c = attr(ling$cult.dist.center,"scaled:center")
ling$cult.dist.center = as.numeric(ling$cult.dist.center)
ling$family1 = l[match(ling$l1, l$iso2),]$family
ling$family2 = l[match(ling$l2, l$iso2),]$family
ling$area1 = l[match(ling$l1, l$iso2),]$autotyp.area
ling$area2 = l[match(ling$l2, l$iso2),]$autotyp.area
fgroup = cbind(ling$family1,ling$family2)
fgroup = apply(fgroup,1,sort)
ling$family.group = apply(fgroup,2,paste,collapse=":")
agroup = cbind(ling$area1,ling$area2)
agroup = apply(agroup,1,sort)
ling$area.group = apply(agroup,2,paste,collapse=":")
ling$rho.center = scale(ling$rho)
```
ling[ling$l1=="Greek",]
head(ling)
ling[ling$l1=="el",]
dim(ling)
---
title: "Cultural distances: controlling for history"
output: pdf_document
---
```{r echo=F, eval=F}
setwd("~/Documents/Bristol/word2vec/word2vec_DPLACE/analysis/")
```
# Introduction
We compare cultural distances between socieites with linguistic similarities between societies, controlling for shared history in two ways.
The first test uses mixed effects modelling.  The pairing of the langauge family of each language (according to Glottolog) is used as a random effect.  That means that the model can capture the likelihood that two languages from the Indo-European langauge family will be more similar to each other than two languages from different langauge families.  The same is done with geographic area according to Autotyp.
The second test controls for history using distances from a phylogenetic tree.  The tree comes from Bouckaert et al. (2012).  Patristic distances between languages are used as a measure of historical distance between societies in a Mantel test.  Note that the Mantel test assumes a strict distance metric, which is not necessarily the case with this data, but there are few other ways to deal with continuous pairwise distances.
# Load libraries
```{r warning=F, message=F}
library(ape)
library(ecodist)
library(lme4)
library(sjPlot)
library(ggplot2)
library(igraph)
library(lattice)
```
# All domains
## Load data
Read the cultural distances:
```{r}
cult = read.csv("../results/EA_distances/CulturalDistances_Long.csv", stringsAsFactors = F)
names(cult) = c("l1","l2","cult.dist")
cultLangs = unique(c(cult$Var1,cult$Var2))
```
Add language family:
```{r}
l = read.csv("../data/FAIR_langauges_glotto_xdid.csv", stringsAsFactors = F)
g = read.csv("../data/glottolog-languoid.csv/languoid.csv", stringsAsFactors = F)
l$family = g[match(l$glotto,g$id),]$family_pk
l$family = g[match(l$family,g$pk),]$name
```
Read the semantic distances
```{r}
ling = read.csv("../data/FAIR/semantic_distances_FAIR_extended.csv", stringsAsFactors = F)
```
Combine the lingusitic and cultural distances
```{r}
cult$l1.iso2 = l[match(cult$l1,l$Language2),]$iso2
cult$l2.iso2 = l[match(cult$l2,l$Language2),]$iso2
fairisos = unique(c(ling$l1,ling$l2))
cultisos = unique(c(cult$l1.iso2, cult$l2.iso2))
cult = cult[(cult$l1.iso2 %in% fairisos) & (cult$l2.iso2 %in% fairisos),]
ling = ling[(ling$l1 %in% cultisos) & (ling$l2 %in% cultisos),]
matches = sapply(1:nrow(ling), function(i){
which(cult$l1.iso2==ling$l1[i] & cult$l2.iso2==ling$l2[i])
})
ling$cult.dist = cult[matches,]$cult.dist
ling$cult.dist.center = scale(ling$cult.dist)
cdc.s = attr(ling$cult.dist.center,"scaled:scale")
cdc.c = attr(ling$cult.dist.center,"scaled:center")
ling$cult.dist.center = as.numeric(ling$cult.dist.center)
ling$family1 = l[match(ling$l1, l$iso2),]$family
ling$family2 = l[match(ling$l2, l$iso2),]$family
ling$area1 = l[match(ling$l1, l$iso2),]$autotyp.area
ling$area2 = l[match(ling$l2, l$iso2),]$autotyp.area
fgroup = cbind(ling$family1,ling$family2)
fgroup = apply(fgroup,1,sort)
ling$family.group = apply(fgroup,2,paste,collapse=":")
agroup = cbind(ling$area1,ling$area2)
agroup = apply(agroup,1,sort)
ling$area.group = apply(agroup,2,paste,collapse=":")
ling$rho.center = scale(ling$rho)
c(ling$l1)
length(unique(c(ling$l1,ling$l2)))
---
title: "Cultural distances: controlling for history"
output: pdf_document
---
```{r echo=F, eval=F}
setwd("~/Documents/Bristol/word2vec/word2vec_DPLACE/analysis/")
```
# Introduction
We compare cultural distances between socieites with linguistic similarities between societies, controlling for shared history in two ways.
The first test uses mixed effects modelling.  The pairing of the language family of each language (according to Glottolog) is used as a random effect.  That means that the model can capture the likelihood that two languages from the Indo-European language family will be more similar to each other than two languages from different language families.  The same is done with geographic area according to Autotyp.
The second test controls for history using distances from a phylogenetic tree.  The tree comes from Bouckaert et al. (2012).  Patristic distances between languages are used as a measure of historical distance between societies in a Mantel test.  Note that the Mantel test assumes a strict distance metric, which is not necessarily the case with this data, but there are few other ways to deal with continuous pairwise distances.
# Load libraries
```{r warning=F, message=F}
library(ape)
library(ecodist)
library(lme4)
library(sjPlot)
library(ggplot2)
library(igraph)
library(lattice)
```
# All domains
## Load data
Read the cultural distances:
```{r}
cult = read.csv("../results/EA_distances/CulturalDistances_Long.csv", stringsAsFactors = F)
names(cult) = c("l1","l2","cult.dist")
cultLangs = unique(c(cult$Var1,cult$Var2))
```
Add language family:
```{r}
l = read.csv("../data/FAIR_languages_glotto_xdid.csv", stringsAsFactors = F)
---
title: "Cultural distances: controlling for history"
output: pdf_document
---
```{r echo=F, eval=F}
setwd("~/Documents/Bristol/word2vec/word2vec_DPLACE/analysis/")
```
# Introduction
We compare cultural distances between socieites with linguistic similarities between societies, controlling for shared history in two ways.
The first test uses mixed effects modelling.  The pairing of the language family of each language (according to Glottolog) is used as a random effect.  That means that the model can capture the likelihood that two languages from the Indo-European language family will be more similar to each other than two languages from different language families.  The same is done with geographic area according to Autotyp.
The second test controls for history using distances from a phylogenetic tree.  The tree comes from Bouckaert et al. (2012).  Patristic distances between languages are used as a measure of historical distance between societies in a Mantel test.  Note that the Mantel test assumes a strict distance metric, which is not necessarily the case with this data, but there are few other ways to deal with continuous pairwise distances.
# Load libraries
```{r warning=F, message=F}
library(ape)
library(ecodist)
library(lme4)
library(sjPlot)
library(ggplot2)
library(igraph)
library(lattice)
```
# All domains
## Load data
Read the cultural distances:
```{r}
cult = read.csv("../results/EA_distances/CulturalDistances_Long.csv", stringsAsFactors = F)
names(cult) = c("l1","l2","cult.dist")
cultLangs = unique(c(cult$Var1,cult$Var2))
```
Add language family:
```{r}
l = read.csv("../data/FAIR_languages_glotto_xdid.csv", stringsAsFactors = F)
ecodist::mantel(as.dist(ling.m2)~
as.dist(cult.m2) +
as.dist(hist.m2),
nperm = 100000)
dim(ling.m2)
library(vegan)
vegan::mantel.partial(as.dist(ling.m2),as.dist(cult.m2),as.dist(hist.m2))
vegan::mantel.partial(as.dist(ling.m2),as.dist(cult.m2),as.dist(hist.m2), permutations = 10000)
vegan::mantel.partial(as.dist(ling.m2),as.dist(cult.m2),as.dist(hist.m2), permutations = 100000)
?daisy
citation("mice")

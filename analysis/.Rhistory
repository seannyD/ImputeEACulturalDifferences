l$family = g[match(l$family,g$pk),]$name
```
Read the semantic distances
```{r}
ling = read.csv("../data/FAIR/semantic_distances_FAIR_extended.csv", stringsAsFactors = F)
```
Combine the lingusitic and cultural distances
```{r}
cult$l1.iso2 = l[match(cult$l1,l$Language2),]$iso2
cult$l2.iso2 = l[match(cult$l2,l$Language2),]$iso2
fairisos = unique(c(ling$l1,ling$l2))
cultisos = unique(c(cult$l1.iso2, cult$l2.iso2))
cult = cult[(cult$l1.iso2 %in% fairisos) & (cult$l2.iso2 %in% fairisos),]
ling = ling[(ling$l1 %in% cultisos) & (ling$l2 %in% cultisos),]
cult[cult]
---
title: "Cultural distances: controlling for history"
output: pdf_document
---
```{r echo=F, eval=F}
setwd("~/Documents/Bristol/word2vec/word2vec_DPLACE/analysis/")
```
# Introduction
We compare cultural distances between socieites with linguistic similarities between societies, controlling for shared history in two ways.
The first test uses mixed effects modelling.  The pairing of the langauge family of each language (according to Glottolog) is used as a random effect.  That means that the model can capture the likelihood that two languages from the Indo-European langauge family will be more similar to each other than two languages from different langauge families.  The same is done with geographic area according to Autotyp.
The second test controls for history using distances from a phylogenetic tree.  The tree comes from Bouckaert et al. (2012).  Patristic distances between languages are used as a measure of historical distance between societies in a Mantel test.  Note that the Mantel test assumes a strict distance metric, which is not necessarily the case with this data, but there are few other ways to deal with continuous pairwise distances.
# Load libraries
```{r warning=F, message=F}
library(ape)
library(ecodist)
library(lme4)
library(sjPlot)
library(ggplot2)
library(igraph)
library(lattice)
```
# All domains
## Load data
Read the cultural distances:
```{r}
cult = read.csv("../results/EA_distances/CulturalDistances_Long.csv", stringsAsFactors = F)
names(cult) = c("l1","l2","cult.dist")
cultLangs = unique(c(cult$Var1,cult$Var2))
```
Add language family:
```{r}
l = read.csv("../data/FAIR_langauges_glotto_xdid.csv", stringsAsFactors = F)
g = read.csv("../data/glottolog-languoid.csv/languoid.csv", stringsAsFactors = F)
l$family = g[match(l$glotto,g$id),]$family_pk
l$family = g[match(l$family,g$pk),]$name
```
Read the semantic distances
```{r}
ling = read.csv("../data/FAIR/semantic_distances_FAIR_extended.csv", stringsAsFactors = F)
```
Combine the lingusitic and cultural distances
```{r}
cult$l1.iso2 = l[match(cult$l1,l$Language2),]$iso2
cult$l2.iso2 = l[match(cult$l2,l$Language2),]$iso2
fairisos = unique(c(ling$l1,ling$l2))
cultisos = unique(c(cult$l1.iso2, cult$l2.iso2))
cult[cult$l1=="Greek",]
l[l$Language2=="Greek",]
fairisos
sort(cultisos)
fairisos = unique(c(ling$l1,ling$l2))
cultisos = unique(c(cult$l1.iso2, cult$l2.iso2))
cult = cult[(cult$l1.iso2 %in% fairisos) & (cult$l2.iso2 %in% fairisos),]
ling = ling[(ling$l1 %in% cultisos) & (ling$l2 %in% cultisos),]
cult[cult$l1=='el',]
cult[cult$l1=="Greek",]
matches = sapply(1:nrow(ling), function(i){
which(cult$l1.iso2==ling$l1[i] & cult$l2.iso2==ling$l2[i])
})
ling$cult.dist = cult[matches,]$cult.dist
ling$cult.dist.center = scale(ling$cult.dist)
cdc.s = attr(ling$cult.dist.center,"scaled:scale")
cdc.c = attr(ling$cult.dist.center,"scaled:center")
ling$cult.dist.center = as.numeric(ling$cult.dist.center)
ling$family1 = l[match(ling$l1, l$iso2),]$family
ling$family2 = l[match(ling$l2, l$iso2),]$family
ling$area1 = l[match(ling$l1, l$iso2),]$autotyp.area
ling$area2 = l[match(ling$l2, l$iso2),]$autotyp.area
fgroup = cbind(ling$family1,ling$family2)
fgroup = apply(fgroup,1,sort)
ling$family.group = apply(fgroup,2,paste,collapse=":")
agroup = cbind(ling$area1,ling$area2)
agroup = apply(agroup,1,sort)
ling$area.group = apply(agroup,2,paste,collapse=":")
ling$rho.center = scale(ling$rho)
```
ling[ling$l1=="Greek",]
head(ling)
ling[ling$l1=="el",]
dim(ling)
---
title: "Cultural distances: controlling for history"
output: pdf_document
---
```{r echo=F, eval=F}
setwd("~/Documents/Bristol/word2vec/word2vec_DPLACE/analysis/")
```
# Introduction
We compare cultural distances between socieites with linguistic similarities between societies, controlling for shared history in two ways.
The first test uses mixed effects modelling.  The pairing of the langauge family of each language (according to Glottolog) is used as a random effect.  That means that the model can capture the likelihood that two languages from the Indo-European langauge family will be more similar to each other than two languages from different langauge families.  The same is done with geographic area according to Autotyp.
The second test controls for history using distances from a phylogenetic tree.  The tree comes from Bouckaert et al. (2012).  Patristic distances between languages are used as a measure of historical distance between societies in a Mantel test.  Note that the Mantel test assumes a strict distance metric, which is not necessarily the case with this data, but there are few other ways to deal with continuous pairwise distances.
# Load libraries
```{r warning=F, message=F}
library(ape)
library(ecodist)
library(lme4)
library(sjPlot)
library(ggplot2)
library(igraph)
library(lattice)
```
# All domains
## Load data
Read the cultural distances:
```{r}
cult = read.csv("../results/EA_distances/CulturalDistances_Long.csv", stringsAsFactors = F)
names(cult) = c("l1","l2","cult.dist")
cultLangs = unique(c(cult$Var1,cult$Var2))
```
Add language family:
```{r}
l = read.csv("../data/FAIR_langauges_glotto_xdid.csv", stringsAsFactors = F)
g = read.csv("../data/glottolog-languoid.csv/languoid.csv", stringsAsFactors = F)
l$family = g[match(l$glotto,g$id),]$family_pk
l$family = g[match(l$family,g$pk),]$name
```
Read the semantic distances
```{r}
ling = read.csv("../data/FAIR/semantic_distances_FAIR_extended.csv", stringsAsFactors = F)
```
Combine the lingusitic and cultural distances
```{r}
cult$l1.iso2 = l[match(cult$l1,l$Language2),]$iso2
cult$l2.iso2 = l[match(cult$l2,l$Language2),]$iso2
fairisos = unique(c(ling$l1,ling$l2))
cultisos = unique(c(cult$l1.iso2, cult$l2.iso2))
cult = cult[(cult$l1.iso2 %in% fairisos) & (cult$l2.iso2 %in% fairisos),]
ling = ling[(ling$l1 %in% cultisos) & (ling$l2 %in% cultisos),]
matches = sapply(1:nrow(ling), function(i){
which(cult$l1.iso2==ling$l1[i] & cult$l2.iso2==ling$l2[i])
})
ling$cult.dist = cult[matches,]$cult.dist
ling$cult.dist.center = scale(ling$cult.dist)
cdc.s = attr(ling$cult.dist.center,"scaled:scale")
cdc.c = attr(ling$cult.dist.center,"scaled:center")
ling$cult.dist.center = as.numeric(ling$cult.dist.center)
ling$family1 = l[match(ling$l1, l$iso2),]$family
ling$family2 = l[match(ling$l2, l$iso2),]$family
ling$area1 = l[match(ling$l1, l$iso2),]$autotyp.area
ling$area2 = l[match(ling$l2, l$iso2),]$autotyp.area
fgroup = cbind(ling$family1,ling$family2)
fgroup = apply(fgroup,1,sort)
ling$family.group = apply(fgroup,2,paste,collapse=":")
agroup = cbind(ling$area1,ling$area2)
agroup = apply(agroup,1,sort)
ling$area.group = apply(agroup,2,paste,collapse=":")
ling$rho.center = scale(ling$rho)
c(ling$l1)
length(unique(c(ling$l1,ling$l2)))
---
title: "Cultural distances: controlling for history"
output: pdf_document
---
```{r echo=F, eval=F}
setwd("~/Documents/Bristol/word2vec/word2vec_DPLACE/analysis/")
```
# Introduction
We compare cultural distances between socieites with linguistic similarities between societies, controlling for shared history in two ways.
The first test uses mixed effects modelling.  The pairing of the language family of each language (according to Glottolog) is used as a random effect.  That means that the model can capture the likelihood that two languages from the Indo-European language family will be more similar to each other than two languages from different language families.  The same is done with geographic area according to Autotyp.
The second test controls for history using distances from a phylogenetic tree.  The tree comes from Bouckaert et al. (2012).  Patristic distances between languages are used as a measure of historical distance between societies in a Mantel test.  Note that the Mantel test assumes a strict distance metric, which is not necessarily the case with this data, but there are few other ways to deal with continuous pairwise distances.
# Load libraries
```{r warning=F, message=F}
library(ape)
library(ecodist)
library(lme4)
library(sjPlot)
library(ggplot2)
library(igraph)
library(lattice)
```
# All domains
## Load data
Read the cultural distances:
```{r}
cult = read.csv("../results/EA_distances/CulturalDistances_Long.csv", stringsAsFactors = F)
names(cult) = c("l1","l2","cult.dist")
cultLangs = unique(c(cult$Var1,cult$Var2))
```
Add language family:
```{r}
l = read.csv("../data/FAIR_languages_glotto_xdid.csv", stringsAsFactors = F)
---
title: "Cultural distances: controlling for history"
output: pdf_document
---
```{r echo=F, eval=F}
setwd("~/Documents/Bristol/word2vec/word2vec_DPLACE/analysis/")
```
# Introduction
We compare cultural distances between socieites with linguistic similarities between societies, controlling for shared history in two ways.
The first test uses mixed effects modelling.  The pairing of the language family of each language (according to Glottolog) is used as a random effect.  That means that the model can capture the likelihood that two languages from the Indo-European language family will be more similar to each other than two languages from different language families.  The same is done with geographic area according to Autotyp.
The second test controls for history using distances from a phylogenetic tree.  The tree comes from Bouckaert et al. (2012).  Patristic distances between languages are used as a measure of historical distance between societies in a Mantel test.  Note that the Mantel test assumes a strict distance metric, which is not necessarily the case with this data, but there are few other ways to deal with continuous pairwise distances.
# Load libraries
```{r warning=F, message=F}
library(ape)
library(ecodist)
library(lme4)
library(sjPlot)
library(ggplot2)
library(igraph)
library(lattice)
```
# All domains
## Load data
Read the cultural distances:
```{r}
cult = read.csv("../results/EA_distances/CulturalDistances_Long.csv", stringsAsFactors = F)
names(cult) = c("l1","l2","cult.dist")
cultLangs = unique(c(cult$Var1,cult$Var2))
```
Add language family:
```{r}
l = read.csv("../data/FAIR_languages_glotto_xdid.csv", stringsAsFactors = F)
ecodist::mantel(as.dist(ling.m2)~
as.dist(cult.m2) +
as.dist(hist.m2),
nperm = 100000)
dim(ling.m2)
library(vegan)
vegan::mantel.partial(as.dist(ling.m2),as.dist(cult.m2),as.dist(hist.m2))
vegan::mantel.partial(as.dist(ling.m2),as.dist(cult.m2),as.dist(hist.m2), permutations = 10000)
vegan::mantel.partial(as.dist(ling.m2),as.dist(cult.m2),as.dist(hist.m2), permutations = 100000)
?daisy
citation("mice")
setwd("~/Documents/Bristol/word2vec/word2vec_DPLACE/analysis/")
library(ape)
library(ecodist)
library(lme4)
library(sjPlot)
library(ggplot2)
library(igraph)
library(lattice)
cult = read.csv("../results/EA_distances/CulturalDistances_Long.csv", stringsAsFactors = F)
names(cult) = c("l1","l2","cult.dist")
cultLangs = unique(c(cult$Var1,cult$Var2))
l = read.csv("../data/FAIR_langauges_glotto_xdid.csv", stringsAsFactors = F)
g = read.csv("../data/glottolog-languoid.csv/languoid.csv", stringsAsFactors = F)
l$family = g[match(l$glotto,g$id),]$family_pk
l$family = g[match(l$family,g$pk),]$name
ling = read.csv("../data/FAIR/semantic_distances_FAIR_extended.csv", stringsAsFactors = F)
hist = read.csv("../data/trees/IndoEuropean_historical_distances.csv", stringsAsFactors = F)
hist = hist[!duplicated(hist[,1]),!duplicated(hist[,1])]
rownames(hist) = hist[,1]
hist = hist[,2:ncol(hist)]
hist.m = as.matrix(hist)
colnames(hist.m) = rownames(hist.m)
hist.m = hist.m/max(hist.m)
cult.m = read.csv("../results/EA_distances/CulturalDistances.csv", stringsAsFactors = F)
rownames(cult.m) = cult.m[,1]
cult.m = cult.m[,2:ncol(cult.m)]
grph <- graph.data.frame(ling[,c("l1",'l2','rho')], directed=FALSE)
# add value as a weight attribute
ling.m = get.adjacency(grph, attr="rho", sparse=FALSE)
rownames(ling.m) = l[match(rownames(ling.m),l$iso2),]$Language2
colnames(ling.m) = l[match(colnames(ling.m),l$iso2),]$Language2
in.analysis = intersect(rownames(ling.m),rownames(cult.m))
in.analysis = intersect(in.analysis, rownames(hist.m))
cult.m2 = cult.m[in.analysis,in.analysis]
ling.m2 = ling.m[in.analysis,in.analysis]
hist.m2 = hist.m[in.analysis,in.analysis]
length(in.analysis)
cult.m2
prod(dim(cult.m2))
(prod(dim(cult.m2))/2)-nrow(cultm2)
(prod(dim(cult.m2))/2)-nrow(cult.m2)
(prod(dim(cult.m2))-nrow(cult.m2))/2
# Take a cultural database and make a distance matrix between societies
library(cluster)
setwd("~/Documents/Bristol/word2vec/word2vec_DPLACE/processing/")
# Load society data
eas = read.csv("../data/dplace-data-1.0/csv/EA_societies.csv", stringsAsFactors = F)
# Load data about variables
eav = read.csv("../data/dplace-data-1.0/csv/EAVariableList.csv", stringsAsFactors = F)
# Load language data
l = read.csv("../data/FAIR_langauges_glotto_xdid.csv", stringsAsFactors = F)
makeDistanceMatrix = function(filename, variables=c()){
# Load imputed Ethnogrpahic Atlas data
eadx = read.csv(filename, stringsAsFactors = F)
# Keep only FAIR langauges
eadx = eadx[eadx$soc_id %in% l$soc.id,]
# Remove family and area data
eadx = eadx[,!names(eadx) %in% c("Family","autotyp.area")]
# Optionally only keep some variables
if(length(variables)>0){
eadx = eadx[,names(eadx) %in% variables]
}
# Remove any variables that still have missing data
eadx = eadx[,apply(eadx,2,function(X){sum(is.na(X))==0})]
#eadx = eadx[,names(eadx)!="X69"]
# Convert to factor
for(i in 1:ncol(eadx)){
eadx[,i] = as.factor(eadx[,i])
}
# Convert soc_id back to character
eadx$soc_id = as.character(eadx$soc_id)
# names of languages according to Facebook
nx = l[match(eadx$soc_id,l$soc.id),]$Language
rownames(eadx) = nx
# Make distance matrix from factors
#dist = dist(eadx[,2:ncol(eadx)])
dist = daisy(eadx[,-which(names(eadx)=="soc_id")], metric = "gower")
# Convert to regular matrix
dist.m = as.matrix(dist)
rownames(dist.m) = nx
colnames(dist.m) = nx
return(dist.m)
}
files = list.files("../data/EA_imputed/completeDataframes/","*.csv")
dists = list()
for(i in 1:length(files)){
print(files[i])
dists[[i]] = makeDistanceMatrix(paste0("../data/EA_imputed/completeDataframes/",files[i]))
}
dim(dists[[i]])
dim(dists[[1]])
dists[[1]]
paste0("../data/EA_imputed/completeDataframes/",files[i])
filename = paste0("../data/EA_imputed/completeDataframes/",files[i])
eadx = read.csv(filename, stringsAsFactors = F)
# Keep only FAIR langauges
eadx = eadx[eadx$soc_id %in% l$soc.id,]
# Remove family and area data
eadx = eadx[,!names(eadx) %in% c("Family","autotyp.area")]
# Optionally only keep some variables
if(length(variables)>0){
eadx = eadx[,names(eadx) %in% variables]
}
# Remove any variables that still have missing data
eadx = eadx[,apply(eadx,2,function(X){sum(is.na(X))==0})]
# Convert to factor
for(i in 1:ncol(eadx)){
eadx[,i] = as.factor(eadx[,i])
}
# Convert soc_id back to character
eadx$soc_id = as.character(eadx$soc_id)
# names of languages according to Facebook
nx = l[match(eadx$soc_id,l$soc.id),]$Language
rownames(eadx) = nx
dim(eadx)
head(eadx)
head(eav)
head(eadx)
gx = sjp.lmer(m1,'pred','cult.dist.center', prnt.plot = F)
m1 = lmer(
rho.center ~ 1 +
cult.dist.center +
(1 + cult.dist.center | family.group) +
(1 + cult.dist.center | area.group),
data = ling
)
anova(m0,m1)
---
title: "Cultural distances: controlling for history"
output: pdf_document
---
```{r echo=F, eval=F}
setwd("~/Documents/Bristol/word2vec/word2vec_DPLACE/analysis/")
```
# Introduction
We compare cultural distances between socieites with linguistic similarities between societies, controlling for shared history in two ways.
The first test uses mixed effects modelling.  The pairing of the language family of each language (according to Glottolog) is used as a random effect.  That means that the model can capture the likelihood that two languages from the Indo-European language family will be more similar to each other than two languages from different language families.  The same is done with geographic area according to Autotyp.
The second test controls for history using distances from a phylogenetic tree.  The tree comes from Bouckaert et al. (2012).  Patristic distances between languages are used as a measure of historical distance between societies in a Mantel test.  Note that the Mantel test assumes a strict distance metric, which is not necessarily the case with this data, but there are few other ways to deal with continuous pairwise distances.
# Load libraries
```{r warning=F, message=F}
library(ape)
library(ecodist)
library(lme4)
library(sjPlot)
library(ggplot2)
library(igraph)
library(lattice)
```
# All domains
## Load data
Read the cultural distances:
```{r}
cult = read.csv("../results/EA_distances/CulturalDistances_Long.csv", stringsAsFactors = F)
names(cult) = c("l1","l2","cult.dist")
cultLangs = unique(c(cult$Var1,cult$Var2))
```
Add language family:
```{r}
l = read.csv("../data/FAIR_langauges_glotto_xdid.csv", stringsAsFactors = F)
g = read.csv("../data/glottolog-languoid.csv/languoid.csv", stringsAsFactors = F)
l$family = g[match(l$glotto,g$id),]$family_pk
l$family = g[match(l$family,g$pk),]$name
```
Read the semantic distances
```{r}
ling = read.csv("../data/FAIR/semantic_distances_FAIR_extended.csv", stringsAsFactors = F)
```
Combine the lingusitic and cultural distances
```{r}
cult$l1.iso2 = l[match(cult$l1,l$Language2),]$iso2
cult$l2.iso2 = l[match(cult$l2,l$Language2),]$iso2
fairisos = unique(c(ling$l1,ling$l2))
cultisos = unique(c(cult$l1.iso2, cult$l2.iso2))
cult = cult[(cult$l1.iso2 %in% fairisos) & (cult$l2.iso2 %in% fairisos),]
ling = ling[(ling$l1 %in% cultisos) & (ling$l2 %in% cultisos),]
matches = sapply(1:nrow(ling), function(i){
which(cult$l1.iso2==ling$l1[i] & cult$l2.iso2==ling$l2[i])
})
ling$cult.dist = cult[matches,]$cult.dist
ling$cult.dist.center = scale(ling$cult.dist)
cdc.s = attr(ling$cult.dist.center,"scaled:scale")
cdc.c = attr(ling$cult.dist.center,"scaled:center")
ling$cult.dist.center = as.numeric(ling$cult.dist.center)
ling$family1 = l[match(ling$l1, l$iso2),]$family
ling$family2 = l[match(ling$l2, l$iso2),]$family
ling$area1 = l[match(ling$l1, l$iso2),]$autotyp.area
ling$area2 = l[match(ling$l2, l$iso2),]$autotyp.area
fgroup = cbind(ling$family1,ling$family2)
fgroup = apply(fgroup,1,sort)
ling$family.group = apply(fgroup,2,paste,collapse=":")
agroup = cbind(ling$area1,ling$area2)
agroup = apply(agroup,1,sort)
ling$area.group = apply(agroup,2,paste,collapse=":")
ling$rho.center = scale(ling$rho)
m1 = lmer(
rho.center ~ 1 +
cult.dist.center +
(1 + cult.dist.center | family.group) +
(1 + cult.dist.center | area.group),
data = ling
)
gx = sjp.lmer(m1,'pred','cult.dist.center', prnt.plot = F)
gx$plot$data$y = gx$plot$data$y *
attr(ling$rho.center,"scaled:scale") +
attr(ling$rho.center,"scaled:center")
gx$plot$data$resp.y = gx$plot$data$resp.y *
attr(ling$rho.center,"scaled:scale") +
attr(ling$rho.center,"scaled:center")
gx$plot$data$x = gx$plot$data$x *
cdc.s +cdc.c
gx$plot
?sjp.lmer
sjp.lmer(m1,'pred','cult.dist.center',
prnt.plot = F,
show.ci=T)
warnings()
sjp.lmer(m1,'pred','cult.dist.center',
prnt.plot = F,
show.ci=T)
sjp.lmer(m1,'pred','cult.dist.center',
prnt.plot = F,
show.ci=T)
gx = sjp.lmer(m1,'pred','cult.dist.center',
prnt.plot = F)
gx$plot$data$y = gx$plot$data$y *
attr(ling$rho.center,"scaled:scale") +
attr(ling$rho.center,"scaled:center")
gx$plot$data$resp.y = gx$plot$data$resp.y *
attr(ling$rho.center,"scaled:scale") +
attr(ling$rho.center,"scaled:center")
gx$plot$data$x = gx$plot$data$x *
cdc.s +cdc.c
gx$plot + coord_cartesian(ylim=c(0.1,0.6),
xlim=c(0.2,0.8)) +
xlab("Cultural distance") +
ylab("Semantic similarity")
gx = gx$plot + coord_cartesian(ylim=c(0.1,0.6),
xlim=c(0.2,0.8)) +
xlab("Cultural distance") +
ylab("Semantic similarity")
pdf("../results/CulturalDistance_Rho_Graph.pdf")
gx
dev.off()
gx = sjp.lmer(m1,'pred','cult.dist.center',
prnt.plot = F)
gx$plot$data$y = gx$plot$data$y *
attr(ling$rho.center,"scaled:scale") +
attr(ling$rho.center,"scaled:center")
gx$plot$data$resp.y = gx$plot$data$resp.y *
attr(ling$rho.center,"scaled:scale") +
attr(ling$rho.center,"scaled:center")
gx$plot$data$x = gx$plot$data$x *
cdc.s +cdc.c
gx = gx$plot + coord_cartesian(ylim=c(0.1,0.6),
xlim=c(0.2,0.8)) +
xlab("Cultural distance") +
ylab("Semantic similarity") +
ggtitle("")
pdf("../results/CulturalDistance_Rho_Graph.pdf",
height=5, width=5)
gx
dev.off()
pdf("../results/CulturalDistance_Rho_Graph.pdf",
height=3.5, width=3.5)
gx
dev.off()
pdf("../results/CulturalDistance_Rho_Graph.pdf",
height=2.5, width=2.5)
gx
dev.off()
dim(ling)
head(ling)
length(unique(c(ling$l1,ling$l2)))
